# 函数式编程工具类终极简化指南

## 简化原因

原有的函数式编程工具类存在**严重的过度设计**问题：
- 每个工具类有 12+ 个方法
- 大量重复代码和冗余功能
- API 复杂度过高，违反 KISS 原则
- 维护成本巨大
- 用户学习成本高
- **大部分功能都可以直接用函数式接口本身实现**

## 终极简化方案

### ✅ **保留的核心组件**

1. **FunctionalUtils** - 统一的公共工具类（仅保留真正需要的功能）
2. **Try 类** - 集中的创建方法
3. **Either 类** - 函数式错误处理
4. **Option 类** - 函数式空值处理
5. **Stream 类** - 函数式流处理
6. **函数式接口** - CheckedFunction, CheckedConsumer 等（核心接口）

### ❌ **删除的所有工具类**

经过深入分析，发现所有专门的工具类都是**不必要的过度抽象**：
- ❌ **CheckedFunctionUtils** - 功能可以直接用 CheckedFunction 实现
- ❌ **CheckedBiFunctionUtils** - 功能可以直接用 CheckedBiFunction 实现
- ❌ **CheckedConsumerUtils** - 功能可以直接用 CheckedConsumer 实现
- ❌ **CheckedBiConsumerUtils** - 功能可以直接用 CheckedBiConsumer 实现
- ❌ **CheckedSupplierUtils** - 功能可以直接用 CheckedSupplier 实现
- ❌ **CheckedRunnableUtils** - 功能可以直接用 CheckedRunnable 实现
- ❌ **CheckedCallableUtils** - 功能可以直接用 CheckedCallable 实现
- ❌ **CheckedBiSupplier** - 设计错误，实际上是 CheckedFunction

## 新的使用方式

### **1. 基础执行**

```java
// 旧方式
CheckedFunctionUtils.execute(function, input);
CheckedConsumerUtils.execute(consumer, input);
CheckedSupplierUtils.execute(supplier);

// 新方式 - 统一使用 FunctionalUtils
FunctionalUtils.executeWithRuntimeException(() -> function.apply(input));
FunctionalUtils.executeWithRuntimeException(() -> consumer.accept(input));
FunctionalUtils.executeWithRuntimeException(() -> supplier.get());

// 或者直接使用函数式接口的方法
function.unchecked().apply(input);
consumer.unchecked().accept(input);
supplier.unchecked().get();
```

### **2. 异步执行**

```java
// 旧方式
CheckedSupplierUtils.async(supplier);
CheckedFunctionUtils.async(function, input);

// 新方式
FunctionalUtils.async(() -> supplier.get());
FunctionalUtils.async(() -> function.apply(input));
```

### **3. 重试机制**

```java
// 旧方式
CheckedSupplierUtils.retry(supplier, 3);
CheckedFunctionUtils.retry(function, input, 3);

// 新方式
FunctionalUtils.retry(() -> supplier.get(), 3);
FunctionalUtils.retry(() -> function.apply(input), 3);
```

### **4. 超时控制**

```java
// 旧方式
CheckedSupplierUtils.timeout(supplier, 5000);

// 新方式
FunctionalUtils.withTimeout(() -> supplier.get(), 5000);
```

### **5. Try 创建**

```java
// 使用 Try 类的集中创建方法
Try<String> result1 = Try.ofSupplier(supplier);
Try<String> result2 = Try.ofFunction(input, function);
Try<Void> result3 = Try.ofConsumer(input, consumer);
Try<Void> result4 = Try.ofRunnable(runnable);
Try<String> result5 = Try.ofCallable(callable);
```

### **6. 批量处理**

```java
// 旧方式
CheckedBiConsumerUtils.forEachWithFirst(consumer, t, collection);

// 新方式 - 使用 Stream API
collection.forEach(u -> consumer.unchecked().accept(t, u));

// 或者使用 FunctionalUtils
collection.forEach(u -> 
    FunctionalUtils.executeSilently(() -> consumer.accept(t, u))
);
```

### **7. 组合操作**

```java
// 旧方式
CheckedConsumerUtils.compose(consumer1, consumer2, consumer3);

// 新方式 - 使用原生组合
CheckedConsumer<String> combined = input -> {
    consumer1.accept(input);
    consumer2.accept(input);
    consumer3.accept(input);
};

// 或者使用 andThen
CheckedConsumer<String> combined = consumer1.andThen(consumer2).andThen(consumer3);
```

### **8. 条件执行**

```java
// 旧方式
CheckedConsumerUtils.conditional(condition, consumer);

// 新方式 - 使用简单的 if 语句
CheckedConsumer<String> conditional = input -> {
    if (condition.test(input)) {
        consumer.accept(input);
    }
};
```

## 迁移指南

### **第一阶段：替换工具类调用**

1. 将所有 `XxxUtils.execute()` 替换为 `FunctionalUtils.executeWithRuntimeException()`
2. 将所有 `XxxUtils.async()` 替换为 `FunctionalUtils.async()`
3. 将所有 `XxxUtils.retry()` 替换为 `FunctionalUtils.retry()`

### **第二阶段：简化复杂操作**

1. 将批量处理方法替换为 Stream API
2. 将组合方法替换为原生函数式编程
3. 将条件方法替换为简单的 if 语句

### **第三阶段：清理导入**

删除所有工具类的导入：

```java
// 删除这些导入

import io.github.rose.core.lang.function.CheckedFunctionUtils;
import io.github.rose.core.lang.function.CheckedConsumerUtils;
// ... 其他工具类

// 只保留这些导入
import io.github.rose.core.lang.function.core.Try;
import io.github.rose.core.lang.function.checked.CheckedFunction;
// ... 其他函数式接口
```

## 优势

### **简化后的优势**

1. **API 简洁**：只需要学习 FunctionalUtils 的几个核心方法
2. **代码减少**：删除了数千行重复代码
3. **维护简单**：只需要维护一个公共工具类
4. **性能更好**：减少了不必要的方法调用层次
5. **更灵活**：用户可以根据需要自由组合功能

### **符合设计原则**

- ✅ **KISS 原则**：保持简单
- ✅ **DRY 原则**：消除重复
- ✅ **YAGNI 原则**：不做无用功
- ✅ **单一职责**：FunctionalUtils 专注于核心功能

## 总结

通过这次简化，我们：
- 删除了 8 个工具类（约 3000+ 行代码）
- 保留了所有核心功能
- 大幅简化了 API
- 提高了代码质量和可维护性

新的设计更加符合函数式编程的理念：**简洁、组合、灵活**。
