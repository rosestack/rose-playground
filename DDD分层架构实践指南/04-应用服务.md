# 4. 应用服务层设计与实现

## 4.1 应用层概述

应用层是领域驱动设计（DDD）中的重要组成部分，位于接口层和领域层之间，是连接外部请求与领域模型的桥梁。应用层不包含业务规则或知识，而是协调任务并将工作委派给领域层中的领域对象进行处理。

### 4.1.1 应用层的定位

在DDD分层架构中，应用层的定位如下：

```
接口层 → 应用层 → 领域层 → 基础设施层
```

- **接口层**：负责处理用户界面或外部系统的请求
- **应用层**：协调和编排领域对象，处理用例流程
- **领域层**：包含业务逻辑和规则，是系统的核心
- **基础设施层**：提供技术支持，如持久化、消息传递等

### 4.1.2 应用层的职责边界

应用层的主要职责是：

1. **用例编排**：组织领域对象完成特定用例
2. **事务管理**：确保用例在一个事务中完成
3. **安全控制**：实施权限检查和访问控制
4. **输入验证**：验证输入数据的合法性
5. **DTO转换**：在接口层和领域层之间转换数据
6. **应用事件发布**：发布应用级别的事件

应用层不应该包含：

1. **业务规则**：业务规则应该在领域层中实现
2. **领域逻辑**：领域逻辑应该由领域对象实现
3. **持久化逻辑**：持久化应该由基础设施层处理

## 4.2 应用层核心职责

### 4.2.1 用例实现

应用服务实现系统用例，每个方法通常对应一个用例。用例实现的典型流程：

1. 接收并验证输入参数（命令对象）
2. 获取并协调领域对象
3. 调用领域对象的方法执行业务逻辑
4. 保存领域对象的状态变化
5. 返回操作结果（DTO对象）

### 4.2.2 事务管理

应用服务负责管理事务边界，确保用例要么完全成功，要么完全失败。在Spring环境中，通常使用`@Transactional`注解来管理事务。

```java
@Service
@Transactional(rollbackFor = Exception.class)
public class UserApplicationService {
    // 服务方法...
}
```

### 4.2.3 安全控制

应用服务实施权限检查和访问控制，确保用户只能访问其有权限的资源。

```java
@PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")
public UserDTO getUser(String userId) {
    // 获取用户信息...
}
```

### 4.2.4 输入验证

应用服务验证输入数据的合法性，确保数据符合业务规则。

```java
public void createUser(@Valid CreateUserCommand command) {
    // 创建用户...
}
```

### 4.2.5 DTO转换

应用服务负责在接口层和领域层之间转换数据，隐藏领域模型的内部结构。

```java
public UserDTO getUser(String userId) {
    User user = userRepository.findById(userId);
    return userDtoAssembler.toDto(user);
}
```

### 4.2.6 应用事件发布

应用服务发布应用级别的事件，通知其他组件发生了某些重要的业务事件。

```java
public void createUser(CreateUserCommand command) {
    // 创建用户...
    applicationEventPublisher.publishEvent(new UserCreatedEvent(user.getId()));
}
```

## 4.3 应用层设计原则

### 4.3.1 单一职责原则

每个应用服务应该只负责一个聚合的操作，避免跨聚合的服务。

- **推荐**：`UserApplicationService`、`OrderApplicationService`
- **不推荐**：`UserAndOrderApplicationService`

### 4.3.2 接口与实现分离

应用服务应该定义接口和实现分离，便于测试和扩展。

```java
public interface UserApplicationService {
    UserDTO getUser(String userId);
    void createUser(CreateUserCommand command);
    // 其他方法...
}

@Service
public class UserApplicationServiceImpl implements UserApplicationService {
    // 实现方法...
}
```

### 4.3.3 命令查询职责分离（CQRS）

将命令（修改状态）和查询（读取状态）分离，可以提高系统的性能和可扩展性。

```java
// 命令服务
public interface UserCommandService {
    void createUser(CreateUserCommand command);
    void updateUser(UpdateUserCommand command);
    void deleteUser(String userId);
}

// 查询服务
public interface UserQueryService {
    UserDTO getUser(String userId);
    List<UserDTO> findUsers(UserQuery query);
}
```

在实际项目中，CQRS模式的实现可以有不同的级别：

1. **简单CQRS**：在同一个应用服务中分离命令和查询方法

```java
@Service
public class UserApplicationServiceImpl implements UserApplicationService {
    // 命令方法（修改状态）
    public void createUser(CreateUserCommand command) { /* ... */ }
    public void updateUser(UpdateUserCommand command) { /* ... */ }
    
    // 查询方法（只读）
    @Transactional(readOnly = true)
    public UserDTO getUser(String userId) { /* ... */ }
    @Transactional(readOnly = true)
    public List<UserDTO> findUsers(UserQuery query) { /* ... */ }
}
```

2. **中级CQRS**：将命令和查询分离为不同的服务类

```java
@Service
public class UserCommandServiceImpl implements UserCommandService {
    private final UserRepository userRepository;
    
    // 命令方法实现...
}

@Service
public class UserQueryServiceImpl implements UserQueryService {
    private final UserRepository userRepository;
    
    // 查询方法实现...
}
```

3. **高级CQRS**：使用不同的数据模型和存储机制

```java
// 命令侧使用领域模型和关系型数据库
@Service
public class UserCommandServiceImpl implements UserCommandService {
    private final UserRepository userRepository; // JPA仓储
    
    // 命令方法实现...
}

// 查询侧使用专用的查询模型和NoSQL数据库或缓存
@Service
public class UserQueryServiceImpl implements UserQueryService {
    private final UserReadModelRepository userReadModelRepository; // MongoDB仓储
    
    // 查询方法实现...
}
```

4. **事件溯源CQRS**：命令侧生成事件，查询侧消费事件更新读模型

```java
@Service
public class UserCommandServiceImpl implements UserCommandService {
    private final EventStore eventStore;
    
    public void createUser(CreateUserCommand command) {
        // 创建用户事件
        UserCreatedEvent event = new UserCreatedEvent(command.getUsername(), command.getEmail());
        // 存储事件
        eventStore.append("user-" + event.getUserId(), event);
    }
}

@Service
public class UserEventHandler {
    private final UserReadModelRepository readModelRepository;
    
    @EventListener
    public void on(UserCreatedEvent event) {
        // 更新读模型
        UserReadModel readModel = new UserReadModel(event.getUserId(), event.getUsername(), event.getEmail());
        readModelRepository.save(readModel);
    }
}
```

### 4.3.4 依赖注入原则

应用服务应该通过构造函数注入依赖，而不是字段注入。

```java
@Service
public class UserApplicationServiceImpl implements UserApplicationService {
    private final UserRepository userRepository;
    private final UserDomainService userDomainService;
    private final UserDtoAssembler userDtoAssembler;
    
    public UserApplicationServiceImpl(UserRepository userRepository,
                                    UserDomainService userDomainService,
                                    UserDtoAssembler userDtoAssembler) {
        this.userRepository = userRepository;
        this.userDomainService = userDomainService;
        this.userDtoAssembler = userDtoAssembler;
    }
    
    // 服务方法...
}
```

### 4.3.5 异常处理原则

应用服务应该捕获领域异常，转换为应用异常或业务异常。

```java
public void createUser(CreateUserCommand command) {
    try {
        // 创建用户...
    } catch (DomainException e) {
        throw new BusinessException("创建用户失败", e);
    }
}
```

## 4.4 用户应用服务设计

以用户管理为例，设计用户应用服务。

### 4.4.1 用户应用服务接口

```java
/**
 * 用户应用服务接口
 * <p>
 * 提供用户管理相关的应用功能，包括用户创建、查询、更新等操作。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public interface UserApplicationService {
    
    /**
     * 创建用户
     *
     * @param command 创建用户命令
     * @return 用户ID
     */
    String createUser(CreateUserCommand command);
    
    /**
     * 激活用户
     *
     * @param userId 用户ID
     */
    void activateUser(String userId);
    
    /**
     * 停用用户
     *
     * @param userId 用户ID
     */
    void deactivateUser(String userId);
    
    /**
     * 更新用户邮箱
     *
     * @param command 更新邮箱命令
     */
    void updateEmail(UpdateEmailCommand command);
    
    /**
     * 更新用户密码
     *
     * @param command 更新密码命令
     */
    void updatePassword(UpdatePasswordCommand command);
    
    /**
     * 获取用户详情
     *
     * @param userId 用户ID
     * @return 用户DTO
     */
    UserDTO getUser(String userId);
    
    /**
     * 查询用户列表
     *
     * @param query 用户查询条件
     * @return 用户DTO列表
     */
    List<UserDTO> findUsers(UserQuery query);
}
```

### 4.4.2 用户应用服务实现

```java
/**
 * 用户应用服务实现
 * <p>
 * 实现用户管理相关的应用功能，协调领域对象完成用户管理用例。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Service
@Transactional(rollbackFor = Exception.class)
public class UserApplicationServiceImpl implements UserApplicationService {
    
    private final UserRepository userRepository;
    private final UserDomainService userDomainService;
    private final UserDtoAssembler userDtoAssembler;
    private final ApplicationEventPublisher eventPublisher;
    
    public UserApplicationServiceImpl(UserRepository userRepository,
                                    UserDomainService userDomainService,
                                    UserDtoAssembler userDtoAssembler,
                                    ApplicationEventPublisher eventPublisher) {
        this.userRepository = userRepository;
        this.userDomainService = userDomainService;
        this.userDtoAssembler = userDtoAssembler;
        this.eventPublisher = eventPublisher;
    }
    
    @Override
    public String createUser(CreateUserCommand command) {
        // 1. 创建用户实体
        User user = User.create(
            command.getUsername(),
            command.getEmail(),
            command.getPassword()
        );
        
        // 2. 保存用户
        userRepository.save(user);
        
        // 3. 发布应用事件
        eventPublisher.publishEvent(new UserCreatedApplicationEvent(user.getId()));
        
        // 4. 返回用户ID
        return user.getId();
    }
    
    @Override
    public void activateUser(String userId) {
        // 1. 获取用户
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new EntityNotFoundException("用户不存在: " + userId));
        
        // 2. 激活用户
        user.activate();
        
        // 3. 保存用户
        userRepository.save(user);
        
        // 4. 发布应用事件
        eventPublisher.publishEvent(new UserStatusChangedApplicationEvent(
            user.getId(), UserStatus.ACTIVE));
    }
    
    @Override
    public void deactivateUser(String userId) {
        // 1. 获取用户
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new EntityNotFoundException("用户不存在: " + userId));
        
        // 2. 停用用户
        user.deactivate();
        
        // 3. 保存用户
        userRepository.save(user);
        
        // 4. 发布应用事件
        eventPublisher.publishEvent(new UserStatusChangedApplicationEvent(
            user.getId(), UserStatus.INACTIVE));
    }
    
    @Override
    public void updateEmail(UpdateEmailCommand command) {
        // 1. 获取用户
        User user = userRepository.findById(command.getUserId())
            .orElseThrow(() -> new EntityNotFoundException("用户不存在: " + command.getUserId()));
        
        // 2. 更新邮箱
        user.updateEmail(command.getEmail());
        
        // 3. 保存用户
        userRepository.save(user);
    }
    
    @Override
    public void updatePassword(UpdatePasswordCommand command) {
        // 1. 获取用户
        User user = userRepository.findById(command.getUserId())
            .orElseThrow(() -> new EntityNotFoundException("用户不存在: " + command.getUserId()));
        
        // 2. 验证旧密码
        if (!user.verifyPassword(command.getOldPassword())) {
            throw new BusinessException("旧密码不正确");
        }
        
        // 3. 更新密码
        user.updatePassword(command.getNewPassword());
        
        // 4. 保存用户
        userRepository.save(user);
    }
    
    @Override
    @Transactional(readOnly = true)
    public UserDTO getUser(String userId) {
        // 1. 获取用户
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new EntityNotFoundException("用户不存在: " + userId));
        
        // 2. 转换为DTO
        return userDtoAssembler.toDto(user);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<UserDTO> findUsers(UserQuery query) {
        // 1. 查询用户
        List<User> users = userRepository.findByQuery(query);
        
        // 2. 转换为DTO
        return userDtoAssembler.toDtoList(users);
    }
}
```

## 4.5 命令对象设计

命令对象是应用服务的输入参数，封装了用例所需的数据。

### 4.5.1 命令对象基类

```java
/**
 * 命令对象基类
 * <p>
 * 所有命令对象的基类，提供通用属性和方法。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public abstract class Command implements Serializable {
    
    /** 命令ID */
    private String commandId;
    
    /** 命令时间戳 */
    private long timestamp;
    
    public Command() {
        this.commandId = UUID.randomUUID().toString();
        this.timestamp = System.currentTimeMillis();
    }
    
    // getter 和 setter 方法...
}
```

### 4.5.2 创建用户命令

```java
/**
 * 创建用户命令
 * <p>
 * 封装创建用户所需的数据。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class CreateUserCommand extends Command {
    
    /** 用户名 */
    @NotBlank(message = "用户名不能为空")
    @Size(min = 4, max = 20, message = "用户名长度必须在4-20之间")
    private String username;
    
    /** 邮箱 */
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;
    
    /** 密码 */
    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20之间")
    private String password;
    
    // getter 和 setter 方法...
}
```

### 4.5.3 更新邮箱命令

```java
/**
 * 更新邮箱命令
 * <p>
 * 封装更新用户邮箱所需的数据。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UpdateEmailCommand extends Command {
    
    /** 用户ID */
    @NotBlank(message = "用户ID不能为空")
    private String userId;
    
    /** 新邮箱 */
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;
    
    // getter 和 setter 方法...
}
```

### 4.5.4 更新密码命令

```java
/**
 * 更新密码命令
 * <p>
 * 封装更新用户密码所需的数据。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UpdatePasswordCommand extends Command {
    
    /** 用户ID */
    @NotBlank(message = "用户ID不能为空")
    private String userId;
    
    /** 旧密码 */
    @NotBlank(message = "旧密码不能为空")
    private String oldPassword;
    
    /** 新密码 */
    @NotBlank(message = "新密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20之间")
    private String newPassword;
    
    // getter 和 setter 方法...
}
```

### 4.5.5 用户查询对象

```java
/**
 * 用户查询对象
 * <p>
 * 封装查询用户列表所需的条件。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UserQuery extends Query {
    
    /** 用户名（模糊匹配） */
    private String username;
    
    /** 邮箱（模糊匹配） */
    private String email;
    
    /** 用户状态 */
    private UserStatus status;
    
    /** 创建时间范围（开始） */
    private LocalDateTime createdTimeStart;
    
    /** 创建时间范围（结束） */
    private LocalDateTime createdTimeEnd;
    
    // getter 和 setter 方法...
}
```

## 4.6 DTO设计

数据传输对象（DTO）是应用服务的输出结果，封装了返回给接口层的数据。

### 4.6.1 DTO基类

```java
/**
 * DTO基类
 * <p>
 * 所有DTO的基类，提供通用属性和方法。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public abstract class BaseDTO implements Serializable {
    
    /** 创建时间 */
    private LocalDateTime createdTime;
    
    /** 更新时间 */
    private LocalDateTime updatedTime;
    
    // getter 和 setter 方法...
}
```

### 4.6.2 用户DTO

```java
/**
 * 用户DTO
 * <p>
 * 封装用户信息，用于返回给接口层。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UserDTO extends BaseDTO {
    
    /** 用户ID */
    private String id;
    
    /** 用户名 */
    private String username;
    
    /** 邮箱 */
    private String email;
    
    /** 用户状态 */
    private UserStatus status;
    
    /** 最后登录时间 */
    private LocalDateTime lastLoginTime;
    
    // getter 和 setter 方法...
}
```

### 4.6.3 DTO装配器

```java
/**
 * 用户DTO装配器
 * <p>
 * 负责在用户实体和用户DTO之间进行转换。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class UserDtoAssembler {
    
    /**
     * 将用户实体转换为用户DTO
     *
     * @param user 用户实体
     * @return 用户DTO
     */
    public UserDTO toDto(User user) {
        if (user == null) {
            return null;
        }
        
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());
        dto.setStatus(user.getStatus());
        dto.setLastLoginTime(user.getLastLoginTime());
        dto.setCreatedTime(user.getCreatedTime());
        dto.setUpdatedTime(user.getUpdatedTime());
        
        return dto;
    }
    
    /**
     * 将用户实体列表转换为用户DTO列表
     *
     * @param users 用户实体列表
     * @return 用户DTO列表
     */
    public List<UserDTO> toDtoList(List<User> users) {
        if (users == null) {
            return Collections.emptyList();
        }
        
        return users.stream()
            .map(this::toDto)
            .collect(Collectors.toList());
    }
}
```

## 4.7 应用事件设计

应用事件是应用层发布的事件，用于通知其他组件发生了某些重要的业务事件。

### 4.7.1 应用事件基类

```java
/**
 * 应用事件基类
 * <p>
 * 所有应用事件的基类，提供通用属性和方法。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public abstract class ApplicationEvent extends ApplicationEvent {
    
    /** 事件ID */
    private final String eventId;
    
    /** 事件时间戳 */
    private final long timestamp;
    
    public ApplicationEvent(Object source) {
        super(source);
        this.eventId = UUID.randomUUID().toString();
        this.timestamp = System.currentTimeMillis();
    }
    
    // getter 方法...
}
```

### 4.7.2 用户创建应用事件

```java
/**
 * 用户创建应用事件
 * <p>
 * 当用户创建成功时发布此事件。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UserCreatedApplicationEvent extends ApplicationEvent {
    
    /** 用户ID */
    private final String userId;
    
    public UserCreatedApplicationEvent(String userId) {
        super(userId);
        this.userId = userId;
    }
    
    public String getUserId() {
        return userId;
    }
}
```

### 4.7.3 用户状态变更应用事件

```java
/**
 * 用户状态变更应用事件
 * <p>
 * 当用户状态变更时发布此事件。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UserStatusChangedApplicationEvent extends ApplicationEvent {
    
    /** 用户ID */
    private final String userId;
    
    /** 新状态 */
    private final UserStatus newStatus;
    
    public UserStatusChangedApplicationEvent(String userId, UserStatus newStatus) {
        super(userId);
        this.userId = userId;
        this.newStatus = newStatus;
    }
    
    public String getUserId() {
        return userId;
    }
    
    public UserStatus getNewStatus() {
        return newStatus;
    }
}
```

## 4.8 应用事件监听器

应用事件监听器负责处理应用事件，执行相应的业务逻辑。

### 4.8.1 用户创建事件监听器

```java
/**
 * 用户创建事件监听器
 * <p>
 * 监听用户创建事件，执行相应的业务逻辑。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class UserCreatedEventListener {
    
    private final EmailService emailService;
    
    public UserCreatedEventListener(EmailService emailService) {
        this.emailService = emailService;
    }
    
    /**
     * 处理用户创建事件
     *
     * @param event 用户创建事件
     */
    @EventListener
    @Async
    public void handleUserCreatedEvent(UserCreatedApplicationEvent event) {
        // 发送欢迎邮件
        emailService.sendWelcomeEmail(event.getUserId());
        
        // 其他业务逻辑...
    }
}
```

### 4.8.2 用户状态变更事件监听器

```java
/**
 * 用户状态变更事件监听器
 * <p>
 * 监听用户状态变更事件，执行相应的业务逻辑。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class UserStatusChangedEventListener {
    
    private final EmailService emailService;
    
    public UserStatusChangedEventListener(EmailService emailService) {
        this.emailService = emailService;
    }
    
    /**
     * 处理用户状态变更事件
     *
     * @param event 用户状态变更事件
     */
    @EventListener
    @Async
    public void handleUserStatusChangedEvent(UserStatusChangedApplicationEvent event) {
        if (event.getNewStatus() == UserStatus.ACTIVE) {
            // 发送激活通知邮件
            emailService.sendActivationEmail(event.getUserId());
        } else if (event.getNewStatus() == UserStatus.INACTIVE) {
            // 发送停用通知邮件
            emailService.sendDeactivationEmail(event.getUserId());
        }
        
        // 其他业务逻辑...
    }
}
```

## 4.9 异常设计

应用层异常设计，包括业务异常和实体未找到异常。

### 4.9.1 业务异常

```java
/**
 * 业务异常
 * <p>
 * 表示业务规则验证失败或业务操作失败。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class BusinessException extends RuntimeException {
    
    /** 错误码 */
    private final String errorCode;
    
    public BusinessException(String message) {
        super(message);
        this.errorCode = "BUSINESS_ERROR";
    }
    
    public BusinessException(String message, Throwable cause) {
        super(message, cause);
        this.errorCode = "BUSINESS_ERROR";
    }
    
    public BusinessException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public BusinessException(String errorCode, String message, Throwable cause) {
        super(message, cause);
        this.errorCode = errorCode;
    }
    
    public String getErrorCode() {
        return errorCode;
    }
}
```

### 4.9.2 实体未找到异常

```java
/**
 * 实体未找到异常
 * <p>
 * 表示查询的实体不存在。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class EntityNotFoundException extends BusinessException {
    
    public EntityNotFoundException(String message) {
        super("ENTITY_NOT_FOUND", message);
    }
    
    public EntityNotFoundException(String entityName, String id) {
        super("ENTITY_NOT_FOUND", entityName + " not found with id: " + id);
    }
}
```

## 4.10 最佳实践

### 4.10.1 应用服务设计原则

1. **保持应用服务轻量级**：应用服务应该只负责协调和编排，不包含业务逻辑
2. **一个应用服务对应一个聚合**：避免跨聚合的应用服务
3. **使用命令对象作为输入**：封装用例所需的数据
4. **使用DTO作为输出**：隐藏领域模型的内部结构
5. **事务边界在应用服务**：确保用例在一个事务中完成
6. **异常处理在应用服务**：捕获领域异常，转换为应用异常

### 4.10.2 命令对象设计原则

1. **命令对象是不可变的**：一旦创建就不应该修改
2. **命令对象包含验证规则**：使用Bean Validation进行验证
3. **命令对象名称反映意图**：如`CreateUserCommand`、`UpdateEmailCommand`
4. **命令对象只包含必要的数据**：不包含不必要的数据

### 4.10.3 DTO设计原则

1. **DTO是简单的数据容器**：不包含业务逻辑
2. **DTO只包含需要的数据**：不暴露不必要的数据
3. **DTO是平面的**：避免复杂的嵌套结构
4. **DTO与领域模型解耦**：DTO的变化不应该影响领域模型

## 4.11 应用层与其他层的交互

应用层作为连接接口层和领域层的桥梁，需要与其他层进行良好的交互。

### 4.11.1 应用层与接口层的交互

应用层通过DTO与接口层交互，接口层调用应用服务，应用服务返回DTO给接口层。

```java
// 接口层控制器
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserApplicationService userApplicationService;
    
    public UserController(UserApplicationService userApplicationService) {
        this.userApplicationService = userApplicationService;
    }
    
    @PostMapping
    public ResponseEntity<String> createUser(@RequestBody @Valid CreateUserRequest request) {
        // 将请求对象转换为命令对象
        CreateUserCommand command = new CreateUserCommand();
        command.setUsername(request.getUsername());
        command.setEmail(request.getEmail());
        command.setPassword(request.getPassword());
        
        // 调用应用服务
        String userId = userApplicationService.createUser(command);
        
        // 返回结果
        return ResponseEntity.created(URI.create("/api/users/" + userId)).body(userId);
    }
    
    @GetMapping("/{userId}")
    public ResponseEntity<UserDTO> getUser(@PathVariable String userId) {
        // 调用应用服务
        UserDTO userDTO = userApplicationService.getUser(userId);
        
        // 返回结果
        return ResponseEntity.ok(userDTO);
    }
}
```

### 4.11.2 应用层与领域层的交互

应用层通过领域服务和仓储接口与领域层交互，应用服务调用领域服务和仓储接口，领域服务和仓储接口返回领域对象给应用服务。

```java
@Service
public class UserApplicationServiceImpl implements UserApplicationService {
    
    private final UserRepository userRepository;
    private final UserDomainService userDomainService;
    
    // 构造函数注入...
    
    @Override
    public void transferMoney(TransferMoneyCommand command) {
        // 获取领域对象
        User fromUser = userRepository.findById(command.getFromUserId())
            .orElseThrow(() -> new EntityNotFoundException("用户不存在"));
        User toUser = userRepository.findById(command.getToUserId())
            .orElseThrow(() -> new EntityNotFoundException("用户不存在"));
        
        // 创建金额值对象
        Money amount = new Money(command.getAmount());
        
        // 调用领域服务执行业务逻辑
        userDomainService.transferMoney(fromUser, toUser, amount);
        
        // 保存领域对象
        userRepository.save(fromUser);
        userRepository.save(toUser);
    }
}
```

### 4.11.3 应用层与基础设施层的交互

应用层通过依赖注入与基础设施层交互，基础设施层实现领域层定义的仓储接口和领域服务接口，应用层通过这些接口间接与基础设施层交互。

```java
@Service
public class UserApplicationServiceImpl implements UserApplicationService {
    
    private final UserRepository userRepository; // 由基础设施层实现
    private final EmailService emailService; // 由基础设施层实现
    
    // 构造函数注入...
    
    @Override
    public void sendVerificationEmail(String userId) {
        // 获取领域对象
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new EntityNotFoundException("用户不存在"));
        
        // 调用基础设施服务
        emailService.sendVerificationEmail(user.getEmail(), user.getVerificationCode());
    }
}
```

## 4.12 应用层性能优化

### 4.12.1 查询优化

对于查询操作，可以采用以下优化策略：

1. **使用只读事务**：查询方法使用`@Transactional(readOnly = true)`注解，提高性能

```java
@Transactional(readOnly = true)
public UserDTO getUser(String userId) {
    // 查询逻辑...
}
```

2. **使用缓存**：对于频繁查询的数据，使用缓存提高性能

```java
@Cacheable(value = "users", key = "#userId")
public UserDTO getUser(String userId) {
    // 查询逻辑...
}
```

3. **分页查询**：对于大量数据的查询，使用分页查询避免一次性加载过多数据

```java
public Page<UserDTO> findUsers(UserQuery query, Pageable pageable) {
    Page<User> userPage = userRepository.findByQuery(query, pageable);
    return userPage.map(userDtoAssembler::toDto);
}
```

### 4.12.2 命令优化

对于命令操作，可以采用以下优化策略：

1. **异步处理**：对于不需要立即响应的操作，使用异步处理提高响应速度

```java
@Async
public CompletableFuture<String> createUserAsync(CreateUserCommand command) {
    // 创建用户逻辑...
    return CompletableFuture.completedFuture(userId);
}
```

2. **批量处理**：对于批量操作，使用批量处理提高性能

```java
public void createUsers(List<CreateUserCommand> commands) {
    List<User> users = commands.stream()
        .map(command -> User.create(
            command.getUsername(),
            command.getEmail(),
            command.getPassword()))
        .collect(Collectors.toList());
    
    userRepository.saveAll(users);
}
```

3. **乐观锁**：对于并发修改，使用乐观锁避免悲观锁的性能问题

```java
public void updateUser(UpdateUserCommand command) {
    User user = userRepository.findById(command.getUserId())
        .orElseThrow(() -> new EntityNotFoundException("用户不存在"));
    
    // 更新用户信息...
    
    try {
        userRepository.save(user); // 使用乐观锁版本号检查
    } catch (OptimisticLockingFailureException e) {
        throw new ConcurrentModificationException("用户信息已被其他人修改");
    }
}
```

## 4.13 总结

应用层是连接接口层和领域层的桥梁，负责协调和编排领域对象完成特定用例。应用层的设计应该遵循单一职责、接口与实现分离、命令查询职责分离等原则，保持应用服务轻量级，将业务逻辑委派给领域层处理。

应用层的核心组件包括应用服务、命令对象、DTO、应用事件和事件监听器等。应用服务实现系统用例，命令对象封装输入数据，DTO封装输出数据，应用事件通知其他组件发生了重要的业务事件。

通过合理设计应用层，可以实现业务逻辑与技术实现的分离，提高系统的可维护性和可扩展性。同时，通过优化应用层的性能和完善测试策略，可以提高系统的响应速度、吞吐量和可靠性。