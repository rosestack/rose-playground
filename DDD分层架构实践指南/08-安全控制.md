## 8. 安全控制

### 8.1 认证机制

#### 8.1.1 JWT 认证

**JWT 配置类：**

```java
/**
 * JWT 配置类
 * 提供JWT令牌的生成、验证和解析功能
 */
@Component
@ConfigurationProperties(prefix = "jwt")
@Data
public class JwtConfig {
    
    /** JWT密钥 */
    private String secret = "mySecretKey";
    
    /** 访问令牌过期时间（秒） */
    private Long accessTokenExpiration = 3600L; // 1小时
    
    /** 刷新令牌过期时间（秒） */
    private Long refreshTokenExpiration = 604800L; // 7天
    
    /** 令牌前缀 */
    private String tokenPrefix = "Bearer ";
    
    /** 请求头名称 */
    private String headerName = "Authorization";
}
```

**JWT 工具类：**

```java
/**
 * JWT 工具类
 * 负责JWT令牌的生成、验证和解析
 */
@Component
@Slf4j
public class JwtTokenProvider {
    
    private final JwtConfig jwtConfig;
    private final Key key;
    
    public JwtTokenProvider(JwtConfig jwtConfig) {
        this.jwtConfig = jwtConfig;
        this.key = Keys.hmacShaKeyFor(jwtConfig.getSecret().getBytes(StandardCharsets.UTF_8));
    }
    
    /**
     * 生成访问令牌
     */
    public String generateAccessToken(UserPrincipal userPrincipal) {
        Date expiryDate = new Date(System.currentTimeMillis() + jwtConfig.getAccessTokenExpiration() * 1000);
        
        return Jwts.builder()
                .setSubject(userPrincipal.getId())
                .setIssuedAt(new Date())
                .setExpiration(expiryDate)
                .claim("username", userPrincipal.getUsername())
                .claim("roles", userPrincipal.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.toList()))
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }
    
    /**
     * 生成刷新令牌
     */
    public String generateRefreshToken(String userId) {
        Date expiryDate = new Date(System.currentTimeMillis() + jwtConfig.getRefreshTokenExpiration() * 1000);
        
        return Jwts.builder()
                .setSubject(userId)
                .setIssuedAt(new Date())
                .setExpiration(expiryDate)
                .claim("type", "refresh")
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }
    
    /**
     * 从令牌中获取用户ID
     */
    public String getUserIdFromToken(String token) {
        Claims claims = Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
        
        return claims.getSubject();
    }
    
    /**
     * 验证令牌
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            log.error("JWT令牌验证失败: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * 从请求中提取令牌
     */
    public String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader(jwtConfig.getHeaderName());
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith(jwtConfig.getTokenPrefix())) {
            return bearerToken.substring(jwtConfig.getTokenPrefix().length());
        }
        return null;
    }
}
```

**JWT 认证过滤器：**

```java
/**
 * JWT 认证过滤器
 * 拦截请求，验证JWT令牌并设置安全上下文
 */
@Component
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    private final JwtTokenProvider tokenProvider;
    private final UserDetailsService userDetailsService;
    
    public JwtAuthenticationFilter(JwtTokenProvider tokenProvider, 
                                 UserDetailsService userDetailsService) {
        this.tokenProvider = tokenProvider;
        this.userDetailsService = userDetailsService;
    }
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        try {
            String token = tokenProvider.extractTokenFromRequest(request);
            
            if (token != null && tokenProvider.validateToken(token)) {
                String userId = tokenProvider.getUserIdFromToken(token);
                UserDetails userDetails = userDetailsService.loadUserByUsername(userId);
                
                UsernamePasswordAuthenticationToken authentication = 
                    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            log.error("无法设置用户认证: {}", e.getMessage());
        }
        
        filterChain.doFilter(request, response);
    }
}
```

#### 8.1.2 OAuth2 集成

**OAuth2 配置：**

```java
/**
 * OAuth2 客户端配置
 */
@Configuration
@EnableOAuth2Client
public class OAuth2Config {
    
    @Bean
    public ClientRegistrationRepository clientRegistrationRepository() {
        return new InMemoryClientRegistrationRepository(
            googleClientRegistration(),
            githubClientRegistration()
        );
    }
    
    private ClientRegistration googleClientRegistration() {
        return ClientRegistration.withRegistrationId("google")
                .clientId("${oauth2.google.client-id}")
                .clientSecret("${oauth2.google.client-secret}")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
                .scope("openid", "profile", "email")
                .authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
                .tokenUri("https://www.googleapis.com/oauth2/v4/token")
                .userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
                .userNameAttributeName(IdTokenClaimNames.SUB)
                .jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
                .clientName("Google")
                .build();
    }
    
    private ClientRegistration githubClientRegistration() {
        return ClientRegistration.withRegistrationId("github")
                .clientId("${oauth2.github.client-id}")
                .clientSecret("${oauth2.github.client-secret}")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
                .scope("read:user")
                .authorizationUri("https://github.com/login/oauth/authorize")
                .tokenUri("https://github.com/login/oauth/access_token")
                .userInfoUri("https://api.github.com/user")
                .userNameAttributeName("id")
                .clientName("GitHub")
                .build();
    }
}
```

#### 8.1.3 多因子认证

**TOTP 多因子认证：**

```java
/**
 * TOTP 多因子认证服务
 */
@Service
@Slf4j
public class TotpService {
    
    private static final String ISSUER = "DDD Demo App";
    private static final int WINDOW = 3;
    
    /**
     * 生成密钥
     */
    public String generateSecretKey() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[20];
        random.nextBytes(bytes);
        return Base32.encode(bytes);
    }
    
    /**
     * 生成QR码URL
     */
    public String generateQrCodeUrl(String username, String secretKey) {
        return String.format(
            "otpauth://totp/%s:%s?secret=%s&issuer=%s",
            URLEncoder.encode(ISSUER, StandardCharsets.UTF_8),
            URLEncoder.encode(username, StandardCharsets.UTF_8),
            secretKey,
            URLEncoder.encode(ISSUER, StandardCharsets.UTF_8)
        );
    }
    
    /**
     * 验证TOTP代码
     */
    public boolean verifyCode(String secretKey, String code) {
        try {
            long timeWindow = System.currentTimeMillis() / 30000;
            
            for (int i = -WINDOW; i <= WINDOW; i++) {
                String expectedCode = generateCode(secretKey, timeWindow + i);
                if (expectedCode.equals(code)) {
                    return true;
                }
            }
            return false;
        } catch (Exception e) {
            log.error("TOTP验证失败: {}", e.getMessage());
            return false;
        }
    }
    
    private String generateCode(String secretKey, long timeWindow) throws Exception {
        byte[] key = Base32.decode(secretKey);
        byte[] data = ByteBuffer.allocate(8).putLong(timeWindow).array();
        
        Mac mac = Mac.getInstance("HmacSHA1");
        mac.init(new SecretKeySpec(key, "HmacSHA1"));
        byte[] hash = mac.doFinal(data);
        
        int offset = hash[hash.length - 1] & 0x0F;
        int code = ((hash[offset] & 0x7F) << 24) |
                   ((hash[offset + 1] & 0xFF) << 16) |
                   ((hash[offset + 2] & 0xFF) << 8) |
                   (hash[offset + 3] & 0xFF);
        
        return String.format("%06d", code % 1000000);
    }
}
```

### 8.2 授权控制

#### 8.2.1 RBAC 权限模型

**角色实体：**

```java
/**
 * 角色实体
 */
@Entity
@Table(name = "roles")
@Data
@EqualsAndHashCode(callSuper = true)
@NoArgsConstructor
@AllArgsConstructor
public class Role extends BaseEntity {
    
    /** 角色名称 */
    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;
    
    /** 角色描述 */
    @Column(name = "description", length = 200)
    private String description;
    
    /** 角色状态 */
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private RoleStatus status = RoleStatus.ACTIVE;
    
    /** 角色权限 */
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "role_permissions",
        joinColumns = @JoinColumn(name = "role_id"),
        inverseJoinColumns = @JoinColumn(name = "permission_id")
    )
    private Set<Permission> permissions = new HashSet<>();
    
    public enum RoleStatus {
        ACTIVE, INACTIVE
    }
    
    /**
     * 添加权限
     */
    public void addPermission(Permission permission) {
        permissions.add(permission);
    }
    
    /**
     * 移除权限
     */
    public void removePermission(Permission permission) {
        permissions.remove(permission);
    }
    
    /**
     * 检查是否有指定权限
     */
    public boolean hasPermission(String permissionCode) {
        return permissions.stream()
                .anyMatch(permission -> permission.getCode().equals(permissionCode));
    }
}
```

**权限实体：**

```java
/**
 * 权限实体
 */
@Entity
@Table(name = "permissions")
@Data
@EqualsAndHashCode(callSuper = true)
@NoArgsConstructor
@AllArgsConstructor
public class Permission extends BaseEntity {
    
    /** 权限代码 */
    @Column(name = "code", nullable = false, unique = true, length = 100)
    private String code;
    
    /** 权限名称 */
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    /** 权限描述 */
    @Column(name = "description", length = 200)
    private String description;
    
    /** 资源类型 */
    @Column(name = "resource_type", length = 50)
    private String resourceType;
    
    /** 操作类型 */
    @Enumerated(EnumType.STRING)
    @Column(name = "action", nullable = false)
    private Action action;
    
    public enum Action {
        CREATE, READ, UPDATE, DELETE, EXECUTE
    }
}
```

#### 8.2.2 权限注解

**权限检查注解：**

```java
/**
 * 权限检查注解
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RequirePermission {
    
    /** 需要的权限代码 */
    String[] value();
    
    /** 权限检查逻辑（AND/OR） */
    LogicalOperator logical() default LogicalOperator.AND;
    
    enum LogicalOperator {
        AND, OR
    }
}
```

**权限检查切面：**

```java
/**
 * 权限检查切面
 */
@Aspect
@Component
@Slf4j
public class PermissionAspect {
    
    private final UserPermissionService userPermissionService;
    
    public PermissionAspect(UserPermissionService userPermissionService) {
        this.userPermissionService = userPermissionService;
    }
    
    @Around("@annotation(requirePermission)")
    public Object checkPermission(ProceedingJoinPoint joinPoint, RequirePermission requirePermission) throws Throwable {
        
        // 获取当前用户
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated()) {
            throw new AccessDeniedException("用户未认证");
        }
        
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        String userId = userPrincipal.getId();
        
        // 检查权限
        String[] requiredPermissions = requirePermission.value();
        boolean hasPermission = checkUserPermissions(userId, requiredPermissions, requirePermission.logical());
        
        if (!hasPermission) {
            log.warn("用户 {} 尝试访问需要权限 {} 的资源", userId, Arrays.toString(requiredPermissions));
            throw new AccessDeniedException("权限不足");
        }
        
        return joinPoint.proceed();
    }
    
    private boolean checkUserPermissions(String userId, String[] permissions, RequirePermission.LogicalOperator logical) {
        if (logical == RequirePermission.LogicalOperator.AND) {
            return Arrays.stream(permissions)
                    .allMatch(permission -> userPermissionService.hasPermission(userId, permission));
        } else {
            return Arrays.stream(permissions)
                    .anyMatch(permission -> userPermissionService.hasPermission(userId, permission));
        }
    }
}
```

#### 8.2.3 动态权限

**动态权限服务：**

```java
/**
 * 动态权限服务
 */
@Service
@Slf4j
public class DynamicPermissionService {
    
    private final UserPermissionService userPermissionService;
    private final RedisTemplate<String, Object> redisTemplate;
    
    public DynamicPermissionService(UserPermissionService userPermissionService,
                                  RedisTemplate<String, Object> redisTemplate) {
        this.userPermissionService = userPermissionService;
        this.redisTemplate = redisTemplate;
    }
    
    /**
     * 检查资源访问权限
     */
    public boolean hasResourcePermission(String userId, String resourceType, String resourceId, String action) {
        // 构建权限键
        String permissionKey = String.format("%s:%s:%s", resourceType, action, resourceId);
        
        // 先检查缓存
        String cacheKey = String.format("user:permission:%s:%s", userId, permissionKey);
        Boolean cachedResult = (Boolean) redisTemplate.opsForValue().get(cacheKey);
        if (cachedResult != null) {
            return cachedResult;
        }
        
        // 检查用户权限
        boolean hasPermission = checkResourcePermission(userId, resourceType, resourceId, action);
        
        // 缓存结果（5分钟）
        redisTemplate.opsForValue().set(cacheKey, hasPermission, Duration.ofMinutes(5));
        
        return hasPermission;
    }
    
    private boolean checkResourcePermission(String userId, String resourceType, String resourceId, String action) {
        // 1. 检查全局权限
        String globalPermission = String.format("%s:%s", resourceType, action);
        if (userPermissionService.hasPermission(userId, globalPermission)) {
            return true;
        }
        
        // 2. 检查资源所有者权限
        if (isResourceOwner(userId, resourceType, resourceId)) {
            String ownerPermission = String.format("%s:%s:owner", resourceType, action);
            if (userPermissionService.hasPermission(userId, ownerPermission)) {
                return true;
            }
        }
        
        // 3. 检查特定资源权限
        String specificPermission = String.format("%s:%s:%s", resourceType, action, resourceId);
        return userPermissionService.hasPermission(userId, specificPermission);
    }
    
    private boolean isResourceOwner(String userId, String resourceType, String resourceId) {
        // 根据资源类型检查所有者关系
        // 这里可以根据具体业务逻辑实现
        return false;
    }
}
```

### 8.3 数据安全

#### 8.3.1 数据加密

**字段加密注解：**

```java
/**
 * 字段加密注解
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Encrypted {
    
    /** 加密算法 */
    EncryptionAlgorithm algorithm() default EncryptionAlgorithm.AES;
    
    enum EncryptionAlgorithm {
        AES, RSA
    }
}
```

**数据加密服务：**

```java
/**
 * 数据加密服务
 */
@Service
@Slf4j
public class DataEncryptionService {
    
    private final AESUtil aesUtil;
    private final RSAUtil rsaUtil;
    
    public DataEncryptionService(AESUtil aesUtil, RSAUtil rsaUtil) {
        this.aesUtil = aesUtil;
        this.rsaUtil = rsaUtil;
    }
    
    /**
     * 加密对象字段
     */
    public void encryptObject(Object obj) {
        if (obj == null) return;
        
        Field[] fields = obj.getClass().getDeclaredFields();
        for (Field field : fields) {
            Encrypted encrypted = field.getAnnotation(Encrypted.class);
            if (encrypted != null) {
                try {
                    field.setAccessible(true);
                    Object value = field.get(obj);
                    if (value instanceof String) {
                        String encryptedValue = encrypt((String) value, encrypted.algorithm());
                        field.set(obj, encryptedValue);
                    }
                } catch (Exception e) {
                    log.error("字段加密失败: {}", e.getMessage());
                }
            }
        }
    }
    
    /**
     * 解密对象字段
     */
    public void decryptObject(Object obj) {
        if (obj == null) return;
        
        Field[] fields = obj.getClass().getDeclaredFields();
        for (Field field : fields) {
            Encrypted encrypted = field.getAnnotation(Encrypted.class);
            if (encrypted != null) {
                try {
                    field.setAccessible(true);
                    Object value = field.get(obj);
                    if (value instanceof String) {
                        String decryptedValue = decrypt((String) value, encrypted.algorithm());
                        field.set(obj, decryptedValue);
                    }
                } catch (Exception e) {
                    log.error("字段解密失败: {}", e.getMessage());
                }
            }
        }
    }
    
    private String encrypt(String data, Encrypted.EncryptionAlgorithm algorithm) {
        switch (algorithm) {
            case AES:
                return aesUtil.encrypt(data);
            case RSA:
                return rsaUtil.encrypt(data);
            default:
                throw new IllegalArgumentException("不支持的加密算法: " + algorithm);
        }
    }
    
    private String decrypt(String encryptedData, Encrypted.EncryptionAlgorithm algorithm) {
        switch (algorithm) {
            case AES:
                return aesUtil.decrypt(encryptedData);
            case RSA:
                return rsaUtil.decrypt(encryptedData);
            default:
                throw new IllegalArgumentException("不支持的加密算法: " + algorithm);
        }
    }
}
```

#### 8.3.2 敏感信息脱敏

**脱敏注解：**

```java
/**
 * 敏感信息脱敏注解
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Sensitive {
    
    /** 脱敏类型 */
    SensitiveType type();
    
    enum SensitiveType {
        /** 手机号 */
        PHONE,
        /** 邮箱 */
        EMAIL,
        /** 身份证号 */
        ID_CARD,
        /** 银行卡号 */
        BANK_CARD,
        /** 姓名 */
        NAME,
        /** 地址 */
        ADDRESS,
        /** 自定义 */
        CUSTOM
    }
}
```

**脱敏处理器：**

```java
/**
 * 敏感信息脱敏处理器
 */
@Component
public class SensitiveDataProcessor {
    
    /**
     * 脱敏处理
     */
    public void maskSensitiveData(Object obj) {
        if (obj == null) return;
        
        Field[] fields = obj.getClass().getDeclaredFields();
        for (Field field : fields) {
            Sensitive sensitive = field.getAnnotation(Sensitive.class);
            if (sensitive != null) {
                try {
                    field.setAccessible(true);
                    Object value = field.get(obj);
                    if (value instanceof String) {
                        String maskedValue = maskData((String) value, sensitive.type());
                        field.set(obj, maskedValue);
                    }
                } catch (Exception e) {
                    log.error("敏感信息脱敏失败: {}", e.getMessage());
                }
            }
        }
    }
    
    private String maskData(String data, Sensitive.SensitiveType type) {
        if (StringUtils.isEmpty(data)) {
            return data;
        }
        
        switch (type) {
            case PHONE:
                return maskPhone(data);
            case EMAIL:
                return maskEmail(data);
            case ID_CARD:
                return maskIdCard(data);
            case BANK_CARD:
                return maskBankCard(data);
            case NAME:
                return maskName(data);
            case ADDRESS:
                return maskAddress(data);
            default:
                return data;
        }
    }
    
    private String maskPhone(String phone) {
        if (phone.length() != 11) return phone;
        return phone.substring(0, 3) + "****" + phone.substring(7);
    }
    
    private String maskEmail(String email) {
        int atIndex = email.indexOf("@");
        if (atIndex <= 1) return email;
        return email.substring(0, 1) + "***" + email.substring(atIndex);
    }
    
    private String maskIdCard(String idCard) {
        if (idCard.length() < 8) return idCard;
        return idCard.substring(0, 4) + "**********" + idCard.substring(idCard.length() - 4);
    }
    
    private String maskBankCard(String bankCard) {
        if (bankCard.length() < 8) return bankCard;
        return bankCard.substring(0, 4) + " **** **** " + bankCard.substring(bankCard.length() - 4);
    }
    
    private String maskName(String name) {
        if (name.length() <= 1) return name;
        return name.substring(0, 1) + "*".repeat(name.length() - 1);
    }
    
    private String maskAddress(String address) {
        if (address.length() <= 6) return address;
        return address.substring(0, 6) + "****";
    }
}
```

#### 8.3.3 数据审计

**审计注解：**

```java
/**
 * 数据审计注解
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Auditable {
    
    /** 操作类型 */
    AuditAction action();
    
    /** 资源类型 */
    String resourceType() default "";
    
    /** 描述 */
    String description() default "";
    
    enum AuditAction {
        CREATE, UPDATE, DELETE, VIEW, EXPORT
    }
}
```

**审计切面：**

```java
/**
 * 数据审计切面
 */
@Aspect
@Component
@Slf4j
public class AuditAspect {
    
    private final AuditLogService auditLogService;
    
    public AuditAspect(AuditLogService auditLogService) {
        this.auditLogService = auditLogService;
    }
    
    @Around("@annotation(auditable)")
    public Object audit(ProceedingJoinPoint joinPoint, Auditable auditable) throws Throwable {
        
        // 获取当前用户
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String userId = authentication != null ? authentication.getName() : "anonymous";
        
        // 获取请求信息
        HttpServletRequest request = getCurrentRequest();
        String ipAddress = getClientIpAddress(request);
        String userAgent = request.getHeader("User-Agent");
        
        // 记录审计日志
        AuditLog auditLog = AuditLog.builder()
                .userId(userId)
                .action(auditable.action().name())
                .resourceType(auditable.resourceType())
                .description(auditable.description())
                .ipAddress(ipAddress)
                .userAgent(userAgent)
                .timestamp(LocalDateTime.now())
                .build();
        
        try {
            Object result = joinPoint.proceed();
            auditLog.setStatus("SUCCESS");
            return result;
        } catch (Exception e) {
            auditLog.setStatus("FAILED");
            auditLog.setErrorMessage(e.getMessage());
            throw e;
        } finally {
            auditLogService.saveAuditLog(auditLog);
        }
    }
    
    private HttpServletRequest getCurrentRequest() {
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        if (requestAttributes instanceof ServletRequestAttributes) {
            return ((ServletRequestAttributes) requestAttributes).getRequest();
        }
        return null;
    }
    
    private String getClientIpAddress(HttpServletRequest request) {
        if (request == null) return "unknown";
        
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (StringUtils.hasText(xForwardedFor)) {
            return xForwardedFor.split(",")[0].trim();
        }
        
        String xRealIp = request.getHeader("X-Real-IP");
        if (StringUtils.hasText(xRealIp)) {
            return xRealIp;
        }
        
        return request.getRemoteAddr();
    }
}
```

### 8.4 安全防护

#### 8.4.1 SQL 注入防护

**SQL 注入防护配置：**

```java
/**
 * SQL 注入防护配置
 */
@Configuration
public class SqlInjectionProtectionConfig {
    
    /**
     * SQL 注入检测过滤器
     */
    @Bean
    public FilterRegistrationBean<SqlInjectionFilter> sqlInjectionFilter() {
        FilterRegistrationBean<SqlInjectionFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new SqlInjectionFilter());
        registration.addUrlPatterns("/*");
        registration.setName("sqlInjectionFilter");
        registration.setOrder(1);
        return registration;
    }
}

/**
 * SQL 注入检测过滤器
 */
@Slf4j
public class SqlInjectionFilter implements Filter {
    
    private static final Pattern SQL_INJECTION_PATTERN = Pattern.compile(
        "(?i)(union|select|insert|update|delete|drop|create|alter|exec|execute|script|javascript|vbscript)",
        Pattern.CASE_INSENSITIVE
    );
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        // 检查请求参数
        if (containsSqlInjection(httpRequest)) {
            log.warn("检测到SQL注入攻击，IP: {}, URI: {}", 
                    httpRequest.getRemoteAddr(), httpRequest.getRequestURI());
            
            httpResponse.setStatus(HttpStatus.BAD_REQUEST.value());
            httpResponse.getWriter().write("Invalid request parameters");
            return;
        }
        
        chain.doFilter(request, response);
    }
    
    private boolean containsSqlInjection(HttpServletRequest request) {
        // 检查查询参数
        Map<String, String[]> parameterMap = request.getParameterMap();
        for (String[] values : parameterMap.values()) {
            for (String value : values) {
                if (SQL_INJECTION_PATTERN.matcher(value).find()) {
                    return true;
                }
            }
        }
        
        // 检查请求头
        Enumeration<String> headerNames = request.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
            String headerValue = request.getHeader(headerName);
            if (SQL_INJECTION_PATTERN.matcher(headerValue).find()) {
                return true;
            }
        }
        
        return false;
    }
}
```

#### 8.4.2 XSS 防护

**XSS 防护过滤器：**

```java
/**
 * XSS 防护过滤器
 */
@Component
@Slf4j
public class XssFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        XssHttpServletRequestWrapper wrappedRequest = new XssHttpServletRequestWrapper((HttpServletRequest) request);
        chain.doFilter(wrappedRequest, response);
    }
}

/**
 * XSS 请求包装器
 */
public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper {
    
    private static final Pattern SCRIPT_PATTERN = Pattern.compile(
        "<script[^>]*>.*?</script>", Pattern.CASE_INSENSITIVE | Pattern.DOTALL
    );
    
    private static final Pattern JAVASCRIPT_PATTERN = Pattern.compile(
        "javascript:", Pattern.CASE_INSENSITIVE
    );
    
    private static final Pattern VBSCRIPT_PATTERN = Pattern.compile(
        "vbscript:", Pattern.CASE_INSENSITIVE
    );
    
    private static final Pattern ONLOAD_PATTERN = Pattern.compile(
        "onload(.*?)=", Pattern.CASE_INSENSITIVE | Pattern.DOTALL
    );
    
    public XssHttpServletRequestWrapper(HttpServletRequest request) {
        super(request);
    }
    
    @Override
    public String getParameter(String name) {
        String value = super.getParameter(name);
        return cleanXss(value);
    }
    
    @Override
    public String[] getParameterValues(String name) {
        String[] values = super.getParameterValues(name);
        if (values != null) {
            for (int i = 0; i < values.length; i++) {
                values[i] = cleanXss(values[i]);
            }
        }
        return values;
    }
    
    @Override
    public String getHeader(String name) {
        String value = super.getHeader(name);
        return cleanXss(value);
    }
    
    private String cleanXss(String value) {
        if (value == null) {
            return null;
        }
        
        // 移除脚本标签
        value = SCRIPT_PATTERN.matcher(value).replaceAll("");
        
        // 移除javascript:
        value = JAVASCRIPT_PATTERN.matcher(value).replaceAll("");
        
        // 移除vbscript:
        value = VBSCRIPT_PATTERN.matcher(value).replaceAll("");
        
        // 移除onload事件
        value = ONLOAD_PATTERN.matcher(value).replaceAll("");
        
        // HTML编码
        value = StringEscapeUtils.escapeHtml4(value);
        
        return value;
    }
}
```

#### 8.4.3 CSRF 防护

**CSRF 防护配置：**

```java
/**
 * CSRF 防护配置
 */
@Configuration
public class CsrfProtectionConfig {
    
    @Bean
    public CsrfTokenRepository csrfTokenRepository() {
        HttpSessionCsrfTokenRepository repository = new HttpSessionCsrfTokenRepository();
        repository.setHeaderName("X-CSRF-TOKEN");
        return repository;
    }
    
    @Bean
    public CsrfFilter csrfFilter() {
        CsrfFilter filter = new CsrfFilter(csrfTokenRepository());
        filter.setRequireCsrfProtectionMatcher(new CsrfRequestMatcher());
        return filter;
    }
    
    /**
     * CSRF 请求匹配器
     */
    private static class CsrfRequestMatcher implements RequestMatcher {
        
        private final Pattern allowedMethods = Pattern.compile("^(GET|HEAD|TRACE|OPTIONS)$");
        private final RegexRequestMatcher unprotectedMatcher = new RegexRequestMatcher("/api/public/.*", null);
        
        @Override
        public boolean matches(HttpServletRequest request) {
            // 允许的HTTP方法不需要CSRF保护
            if (allowedMethods.matcher(request.getMethod()).matches()) {
                return false;
            }
            
            // 公开API不需要CSRF保护
            if (unprotectedMatcher.matches(request)) {
                return false;
            }
            
            return true;
        }
    }
}