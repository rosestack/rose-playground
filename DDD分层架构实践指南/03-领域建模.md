# 3. 领域建模

## 3.1 领域层概述

领域层是DDD分层架构的核心，包含了业务的核心逻辑和规则。它是整个系统的业务知识库，独立于任何技术实现细节。

### 3.1.1 核心职责

- **业务逻辑实现**：封装核心业务规则和计算逻辑
- **业务不变性保证**：确保业务规则在任何情况下都不被违反
- **领域模型定义**：定义实体、值对象、聚合等领域概念
- **领域事件发布**：在业务状态变化时发布相应的领域事件
- **业务规则验证**：在领域对象内部进行业务规则验证

### 3.1.2 设计原则

- **业务逻辑纯净**：不依赖任何技术框架或外部系统
- **充血模型**：实体包含业务行为，不仅仅是数据容器
- **单一职责**：每个领域对象都有明确的业务职责
- **封装性**：隐藏内部实现细节，只暴露必要的业务接口
- **一致性**：聚合内部保持业务规则的一致性

## 3.2 基础组件设计

### 3.2.1 基础模型类

```java
/**
 * 领域模型基类
 * <p>
 * 提供领域对象的基础功能，包括唯一标识和基础属性。
 * 
 * @param <ID> 标识符类型
 * @author chensoul
 * @since 1.0.0
 */
public abstract class BaseEntity<ID> {
    /** 唯一标识符 */
    protected ID id;
    
    /** 创建时间 */
    protected LocalDateTime createdAt;
    
    /** 更新时间 */
    protected LocalDateTime updatedAt;
    
    protected BaseEntity() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    protected BaseEntity(ID id) {
        this();
        this.id = id;
    }
    
    /**
     * 获取唯一标识符
     */
    public ID getId() {
        return id;
    }
    
    /**
     * 更新时间戳
     */
    protected void updateTimestamp() {
        this.updatedAt = LocalDateTime.now();
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        BaseEntity<?> that = (BaseEntity<?>) obj;
        return Objects.equals(id, that.id);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}
```

### 3.2.2 聚合根基类

```java
/**
 * 聚合根基类
 * <p>
 * 为聚合根提供领域事件管理功能。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public abstract class AggregateRoot<ID> extends BaseEntity<ID> {
    /** 领域事件列表 */
    private final List<DomainEvent<? extends AggregateRoot<ID>>> domainEvents = new ArrayList<>();
    
    protected AggregateRoot() {
        super();
    }
    
    protected AggregateRoot(ID id) {
        super(id);
    }
    
    /**
     * 添加领域事件
     */
    protected void addDomainEvent(DomainEvent<? extends AggregateRoot<ID>> event) {
        this.domainEvents.add(event);
    }
    
    /**
     * 获取所有领域事件
     */
    public List<DomainEvent<? extends AggregateRoot<ID>>> getDomainEvents() {
        return Collections.unmodifiableList(domainEvents);
    }
    
    /**
     * 清除所有领域事件
     */
    public void clearDomainEvents() {
        this.domainEvents.clear();
    }
}
```

### 3.2.3 领域事件基类

```java
/**
 * 领域事件基类
 * <p>
 * 表示领域内发生的重要业务事件。
 * 
 * @param <T> 聚合根类型
 * @author chensoul
 * @since 1.0.0
 */
public abstract class DomainEvent<T extends AggregateRoot<?>> {
    /** 事件唯一标识 */
    private final String eventId;
    
    /** 事件发生时间 */
    private final LocalDateTime occurredOn;
    
    /** 聚合根标识 */
    private final Object aggregateId;
    
    protected DomainEvent(Object aggregateId) {
        this.eventId = UUID.randomUUID().toString();
        this.occurredOn = LocalDateTime.now();
        this.aggregateId = aggregateId;
    }
    
    public String getEventId() {
        return eventId;
    }
    
    public LocalDateTime getOccurredOn() {
        return occurredOn;
    }
    
    public Object getAggregateId() {
        return aggregateId;
    }
}
```

## 3.3 实体设计

### 3.3.1 用户实体

```java
/**
 * 用户聚合根
 * <p>
 * 用户领域的核心实体，包含用户的基本信息和业务行为。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class User extends AggregateRoot<String> {
    /** 用户名 */
    private String username;
    
    /** 邮箱 */
    private String email;
    
    /** 密码（加密后） */
    private String password;
    
    /** 用户状态 */
    private UserStatus status;
    
    /** 私有构造函数，防止直接实例化 */
    private User() {
        super();
    }
    
    private User(String id, String username, String email, String password) {
        super(id);
        this.username = username;
        this.email = email;
        this.password = password;
        this.status = UserStatus.INACTIVE;
    }
    
    /**
     * 创建新用户
     */
    public static User create(String username, String email, String password) {
        // 业务规则验证
        validateUsername(username);
        validateEmail(email);
        validatePassword(password);
        
        String userId = UUID.randomUUID().toString();
        User user = new User(userId, username, email, password);
        
        // 发布用户创建事件
        user.addDomainEvent(new UserCreatedEvent(userId, username, email));
        
        return user;
    }
    
    /**
     * 激活用户
     */
    public void activate() {
        if (this.status == UserStatus.DELETED) {
            throw new DomainException("已删除的用户无法激活");
        }
        
        this.status = UserStatus.ACTIVE;
        this.updateTimestamp();
        
        // 发布用户激活事件
        addDomainEvent(new UserActivatedEvent(this.id));
    }
    
    /**
     * 停用用户
     */
    public void deactivate() {
        if (this.status == UserStatus.DELETED) {
            throw new DomainException("已删除的用户无法停用");
        }
        
        this.status = UserStatus.INACTIVE;
        this.updateTimestamp();
        
        // 发布用户停用事件
        addDomainEvent(new UserDeactivatedEvent(this.id));
    }
    
    /**
     * 更新邮箱
     */
    public void changeEmail(String newEmail) {
        validateEmail(newEmail);
        
        if (this.status != UserStatus.ACTIVE) {
            throw new DomainException("非活跃用户无法修改邮箱");
        }
        
        String oldEmail = this.email;
        this.email = newEmail;
        this.updateTimestamp();
        
        // 发布邮箱变更事件
        addDomainEvent(new UserEmailChangedEvent(this.id, oldEmail, newEmail));
    }
    
    /**
     * 更新密码
     */
    public void changePassword(String oldPassword, String newPassword) {
        if (!this.password.equals(oldPassword)) {
            throw new DomainException("原密码不正确");
        }
        
        validatePassword(newPassword);
        
        this.password = newPassword;
        this.updateTimestamp();
        
        // 发布密码变更事件
        addDomainEvent(new UserPasswordChangedEvent(this.id));
    }
    
    /**
     * 检查用户是否可以执行操作
     */
    public boolean canPerformAction() {
        return this.status == UserStatus.ACTIVE;
    }
    
    // 业务规则验证方法
    private static void validateUsername(String username) {
        if (username == null || username.trim().isEmpty()) {
            throw new DomainException("用户名不能为空");
        }
        if (username.length() < 3 || username.length() > 20) {
            throw new DomainException("用户名长度必须在3-20个字符之间");
        }
        if (!username.matches("^[a-zA-Z0-9_]+$")) {
            throw new DomainException("用户名只能包含字母、数字和下划线");
        }
    }
    
    private static void validateEmail(String email) {
        if (email == null || email.trim().isEmpty()) {
            throw new DomainException("邮箱不能为空");
        }
        if (!email.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
            throw new DomainException("邮箱格式不正确");
        }
    }
    
    private static void validatePassword(String password) {
        if (password == null || password.trim().isEmpty()) {
            throw new DomainException("密码不能为空");
        }
        if (password.length() < 6) {
            throw new DomainException("密码长度不能少于6位");
        }
    }
    
    // Getter方法
    public String getUsername() { return username; }
    public String getEmail() { return email; }
    public UserStatus getStatus() { return status; }
}
```

### 3.3.2 用户状态枚举

```java
/**
 * 用户状态枚举
 * 
 * @author chensoul
 * @since 1.0.0
 */
public enum UserStatus {
    /** 活跃状态 */
    ACTIVE("活跃"),
    
    /** 非活跃状态 */
    INACTIVE("非活跃"),
    
    /** 已删除状态 */
    DELETED("已删除");
    
    private final String description;
    
    UserStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
```

## 3.4 值对象设计

### 3.4.1 金额值对象

```java
/**
 * 金额值对象
 * <p>
 * 封装金额相关的业务逻辑和验证规则。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class Money {
    /** 金额数值 */
    private final BigDecimal amount;
    
    /** 货币类型 */
    private final String currency;
    
    private Money(BigDecimal amount, String currency) {
        this.amount = amount;
        this.currency = currency;
    }
    
    /**
     * 创建金额对象
     */
    public static Money of(BigDecimal amount, String currency) {
        validateAmount(amount);
        validateCurrency(currency);
        
        return new Money(amount, currency);
    }
    
    /**
     * 创建人民币金额
     */
    public static Money ofCNY(BigDecimal amount) {
        return of(amount, "CNY");
    }
    
    /**
     * 加法运算
     */
    public Money add(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new DomainException("不同货币类型无法进行运算");
        }
        
        return new Money(this.amount.add(other.amount), this.currency);
    }
    
    /**
     * 减法运算
     */
    public Money subtract(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new DomainException("不同货币类型无法进行运算");
        }
        
        BigDecimal result = this.amount.subtract(other.amount);
        if (result.compareTo(BigDecimal.ZERO) < 0) {
            throw new DomainException("金额不能为负数");
        }
        
        return new Money(result, this.currency);
    }
    
    /**
     * 乘法运算
     */
    public Money multiply(BigDecimal multiplier) {
        if (multiplier.compareTo(BigDecimal.ZERO) < 0) {
            throw new DomainException("乘数不能为负数");
        }
        
        return new Money(this.amount.multiply(multiplier), this.currency);
    }
    
    /**
     * 比较大小
     */
    public int compareTo(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new DomainException("不同货币类型无法比较");
        }
        
        return this.amount.compareTo(other.amount);
    }
    
    /**
     * 是否大于
     */
    public boolean isGreaterThan(Money other) {
        return compareTo(other) > 0;
    }
    
    /**
     * 是否等于
     */
    public boolean isEqualTo(Money other) {
        return compareTo(other) == 0;
    }
    
    private static void validateAmount(BigDecimal amount) {
        if (amount == null) {
            throw new DomainException("金额不能为空");
        }
        if (amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new DomainException("金额不能为负数");
        }
        if (amount.scale() > 2) {
            throw new DomainException("金额最多保留两位小数");
        }
    }
    
    private static void validateCurrency(String currency) {
        if (currency == null || currency.trim().isEmpty()) {
            throw new DomainException("货币类型不能为空");
        }
        if (!currency.matches("^[A-Z]{3}$")) {
            throw new DomainException("货币类型格式不正确");
        }
    }
    
    public BigDecimal getAmount() { return amount; }
    public String getCurrency() { return currency; }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Money money = (Money) obj;
        return Objects.equals(amount, money.amount) && 
               Objects.equals(currency, money.currency);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(amount, currency);
    }
    
    @Override
    public String toString() {
        return amount + " " + currency;
    }
}
```

## 3.5 领域服务设计

### 3.5.1 用户领域服务

```java
/**
 * 用户领域服务接口
 * <p>
 * 定义跨用户实体的业务逻辑和复杂的业务规则。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public interface UserDomainService {
    
    /**
     * 检查用户名是否唯一
     */
    boolean isUsernameUnique(String username);
    
    /**
     * 检查邮箱是否唯一
     */
    boolean isEmailUnique(String email);
    
    /**
     * 验证用户创建规则
     */
    void validateUserCreation(String username, String email);
}

/**
 * 用户领域服务实现
 * <p>
 * 处理跨用户实体的业务逻辑和复杂的业务规则。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UserDomainServiceImpl implements UserDomainService {
    
    private final UserRepository userRepository;
    
    public UserDomainServiceImpl(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    /**
     * 检查用户名是否唯一
     */
    @Override
    public boolean isUsernameUnique(String username) {
        return userRepository.findByUsername(username).isEmpty();
    }
    
    /**
     * 检查邮箱是否唯一
     */
    @Override
    public boolean isEmailUnique(String email) {
        return userRepository.findByEmail(email).isEmpty();
    }
    
    /**
     * 验证用户创建规则
     */
    @Override
    public void validateUserCreation(String username, String email) {
        if (!isUsernameUnique(username)) {
            throw new DomainException("用户名已存在");
        }
        
        if (!isEmailUnique(email)) {
            throw new DomainException("邮箱已被使用");
        }
    }
}
```

## 3.6 仓储接口设计

### 3.6.1 用户仓储接口

```java
/**
 * 用户仓储接口
 * <p>
 * 定义用户聚合的持久化契约，不包含具体实现。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public interface UserRepository {
    
    /**
     * 保存用户
     */
    void save(User user);
    
    /**
     * 根据ID查找用户
     */
    Optional<User> findById(String id);
    
    /**
     * 根据用户名查找用户
     */
    Optional<User> findByUsername(String username);
    
    /**
     * 根据邮箱查找用户
     */
    Optional<User> findByEmail(String email);
    
    /**
     * 根据条件查询用户列表
     */
    List<User> findByCondition(UserQueryCondition condition);
    
    /**
     * 分页查询用户
     */
    Page<User> findByConditionWithPage(UserQueryCondition condition, Pageable pageable);
    
    /**
     * 统计用户数量
     */
    long countByCondition(UserQueryCondition condition);
    
    /**
     * 删除用户
     */
    void delete(User user);
    
    /**
     * 检查用户是否存在
     */
    boolean existsById(String id);
    
    /**
     * 检查用户名是否存在
     */
    boolean existsByUsername(String username);
    
    /**
     * 检查邮箱是否存在
     */
    boolean existsByEmail(String email);
}
```

## 3.7 领域事件设计

### 3.7.1 事件发布和处理机制

#### 事件发布器接口

```java
/**
 * 领域事件发布器接口
 * <p>
 * 负责发布领域事件到事件总线。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public interface DomainEventPublisher {
    
    /**
     * 发布单个领域事件
     */
    void publish(DomainEvent<?> event);
    
    /**
     * 批量发布领域事件
     */
    void publishAll(List<DomainEvent<?>> events);
    
    /**
     * 发布聚合根中的所有事件
     */
    void publishEvents(AggregateRoot aggregateRoot);
}
```

#### 事件发布器实现

```java
/**
 * Spring 事件发布器实现
 * <p>
 * 基于 Spring ApplicationEventPublisher 实现事件发布。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class SpringDomainEventPublisher implements DomainEventPublisher {
    
    private final ApplicationEventPublisher applicationEventPublisher;
    private final Logger logger = LoggerFactory.getLogger(SpringDomainEventPublisher.class);
    
    public SpringDomainEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        this.applicationEventPublisher = applicationEventPublisher;
    }
    
    /**
     * 发布单个领域事件
     */
    @Override
    public void publish(DomainEvent<?> event) {
        try {
            logger.debug("发布领域事件: {}", event);
            applicationEventPublisher.publishEvent(event);
        } catch (Exception e) {
            logger.error("发布领域事件失败: {}", event, e);
            throw new DomainException("事件发布失败", e);
        }
    }
    
    /**
     * 批量发布领域事件
     */
    @Override
    public void publishAll(List<DomainEvent<?>> events) {
        if (events == null || events.isEmpty()) {
            return;
        }
        
        for (DomainEvent<?> event : events) {
            publish(event);
        }
    }
    
    /**
     * 发布聚合根中的所有事件
     */
    @Override
    public void publishEvents(AggregateRoot aggregateRoot) {
        List<DomainEvent<?>> events = aggregateRoot.getDomainEvents();
        publishAll(events);
        aggregateRoot.clearDomainEvents();
    }
}
```

#### 事件处理器接口

```java
/**
 * 领域事件处理器接口
 * <p>
 * 定义领域事件处理的契约。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public interface DomainEventHandler<T extends DomainEvent<?>> {
    
    /**
     * 处理领域事件
     */
    void handle(T event);
    
    /**
     * 获取支持的事件类型
     */
    Class<T> getSupportedEventType();
    
    /**
     * 获取处理器优先级（数字越小优先级越高）
     */
    default int getOrder() {
        return 0;
    }
}
```

### 3.7.2 具体事件定义

#### 用户创建事件

```java
/**
 * 用户创建事件
 * <p>
 * 当新用户被创建时发布此事件。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UserCreatedEvent extends DomainEvent<User> {
    /** 用户名 */
    private final String username;
    
    /** 邮箱 */
    private final String email;
    
    public UserCreatedEvent(String userId, String username, String email) {
        super(userId);
        this.username = username;
        this.email = email;
    }
    
    public String getUsername() {
        return username;
    }
    
    public String getEmail() {
        return email;
    }
    
    @Override
    public String toString() {
        return String.format("UserCreatedEvent{userId=%s, username=%s, email=%s, occurredOn=%s}", 
                           getAggregateId(), username, email, getOccurredOn());
    }
}
```

#### 用户激活事件

```java
/**
 * 用户激活事件
 * <p>
 * 当用户被激活时发布此事件。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UserActivatedEvent extends DomainEvent<User> {
    
    public UserActivatedEvent(String userId) {
        super(userId);
    }
    
    @Override
    public String toString() {
        return String.format("UserActivatedEvent{userId=%s, occurredOn=%s}", 
                           getAggregateId(), getOccurredOn());
    }
}
```

#### 用户停用事件

```java
/**
 * 用户停用事件
 * <p>
 * 当用户被停用时发布此事件。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UserDeactivatedEvent extends DomainEvent<User> {
    
    public UserDeactivatedEvent(String userId) {
        super(userId);
    }
    
    @Override
    public String toString() {
        return String.format("UserDeactivatedEvent{userId=%s, occurredOn=%s}", 
                           getAggregateId(), getOccurredOn());
    }
}
```

#### 用户邮箱变更事件

```java
/**
 * 用户邮箱变更事件
 * <p>
 * 当用户邮箱被修改时发布此事件。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UserEmailChangedEvent extends DomainEvent<User> {
    /** 原邮箱 */
    private final String oldEmail;
    
    /** 新邮箱 */
    private final String newEmail;
    
    public UserEmailChangedEvent(String userId, String oldEmail, String newEmail) {
        super(userId);
        this.oldEmail = oldEmail;
        this.newEmail = newEmail;
    }
    
    public String getOldEmail() {
        return oldEmail;
    }
    
    public String getNewEmail() {
        return newEmail;
    }
    
    @Override
    public String toString() {
        return String.format("UserEmailChangedEvent{userId=%s, oldEmail=%s, newEmail=%s, occurredOn=%s}", 
                           getAggregateId(), oldEmail, newEmail, getOccurredOn());
    }
}
```

#### 用户密码变更事件

```java
/**
 * 用户密码变更事件
 * <p>
 * 当用户密码被修改时发布此事件。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UserPasswordChangedEvent extends DomainEvent<User> {
    
    public UserPasswordChangedEvent(String userId) {
        super(userId);
    }
    
    @Override
    public String toString() {
        return String.format("UserPasswordChangedEvent{userId=%s, occurredOn=%s}", 
                           getAggregateId(), getOccurredOn());
    }
}
```

### 3.7.3 事件处理器实现

#### 用户创建事件处理器

```java
/**
 * 用户创建事件处理器
 * <p>
 * 处理用户创建后的相关业务逻辑。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class UserCreatedEventHandler implements DomainEventHandler<UserCreatedEvent> {
    
    private final Logger logger = LoggerFactory.getLogger(UserCreatedEventHandler.class);
    
    /**
     * 处理用户创建事件
     */
    @Override
    @EventListener
    @Async
    public void handle(UserCreatedEvent event) {
        try {
            logger.info("处理用户创建事件: {}", event);
            
            // 发送欢迎邮件
            sendWelcomeEmail(event.getAggregateId(), event.getEmail());
            
            // 初始化用户配置
            initializeUserSettings(event.getAggregateId());
            
            // 记录用户创建日志
            logUserCreation(event);
            
        } catch (Exception e) {
            logger.error("处理用户创建事件失败: {}", event, e);
            // 这里可以考虑重试机制或者发送到死信队列
        }
    }
    
    @Override
    public Class<UserCreatedEvent> getSupportedEventType() {
        return UserCreatedEvent.class;
    }
    
    private void sendWelcomeEmail(String userId, String email) {
        // 发送欢迎邮件的逻辑
        logger.debug("为用户 {} 发送欢迎邮件到 {}", userId, email);
    }
    
    private void initializeUserSettings(String userId) {
        // 初始化用户配置的逻辑
        logger.debug("为用户 {} 初始化默认配置", userId);
    }
    
    private void logUserCreation(UserCreatedEvent event) {
        // 记录用户创建审计日志
        logger.info("用户创建审计日志: userId={}, username={}, email={}, time={}", 
                   event.getAggregateId(), event.getUsername(), event.getEmail(), event.getOccurredOn());
    }
}
```

#### 用户邮箱变更事件处理器

```java
/**
 * 用户邮箱变更事件处理器
 * <p>
 * 处理用户邮箱变更后的相关业务逻辑。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class UserEmailChangedEventHandler implements DomainEventHandler<UserEmailChangedEvent> {
    
    private final Logger logger = LoggerFactory.getLogger(UserEmailChangedEventHandler.class);
    
    /**
     * 处理用户邮箱变更事件
     */
    @Override
    @EventListener
    @Async
    public void handle(UserEmailChangedEvent event) {
        try {
            logger.info("处理用户邮箱变更事件: {}", event);
            
            // 发送邮箱变更通知到新邮箱
            sendEmailChangeNotification(event.getAggregateId(), event.getNewEmail());
            
            // 发送邮箱变更通知到旧邮箱
            sendEmailChangeNotification(event.getAggregateId(), event.getOldEmail());
            
            // 更新相关系统的邮箱信息
            updateRelatedSystems(event.getAggregateId(), event.getNewEmail());
            
            // 记录邮箱变更日志
            logEmailChange(event);
            
        } catch (Exception e) {
            logger.error("处理用户邮箱变更事件失败: {}", event, e);
        }
    }
    
    @Override
    public Class<UserEmailChangedEvent> getSupportedEventType() {
        return UserEmailChangedEvent.class;
    }
    
    private void sendEmailChangeNotification(String userId, String email) {
        // 发送邮箱变更通知的逻辑
        logger.debug("为用户 {} 发送邮箱变更通知到 {}", userId, email);
    }
    
    private void updateRelatedSystems(String userId, String newEmail) {
        // 更新相关系统邮箱信息的逻辑
        logger.debug("为用户 {} 更新相关系统邮箱信息: {}", userId, newEmail);
    }
    
    private void logEmailChange(UserEmailChangedEvent event) {
        // 记录邮箱变更审计日志
        logger.info("用户邮箱变更审计日志: userId={}, oldEmail={}, newEmail={}, time={}", 
                   event.getAggregateId(), event.getOldEmail(), event.getNewEmail(), event.getOccurredOn());
    }
}
```

### 3.7.4 事件存储和重放

#### 事件存储接口

```java
/**
 * 事件存储接口
 * <p>
 * 用于持久化领域事件，支持事件溯源。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public interface EventStore {
    
    /**
     * 保存事件
     */
    void saveEvent(DomainEvent<?> event);
    
    /**
     * 批量保存事件
     */
    void saveEvents(List<DomainEvent<?>> events);
    
    /**
     * 根据聚合ID获取事件流
     */
    List<DomainEvent<?>> getEventStream(String aggregateId);
    
    /**
     * 根据聚合ID和版本获取事件流
     */
    List<DomainEvent<?>> getEventStream(String aggregateId, long fromVersion);
    
    /**
     * 获取所有事件（分页）
     */
    Page<DomainEvent<?>> getAllEvents(Pageable pageable);
    
    /**
     * 根据事件类型获取事件
     */
    List<DomainEvent<?>> getEventsByType(Class<? extends DomainEvent<?>> eventType);
}
```

### 3.7.5 事件处理最佳实践

#### 事件处理配置

```java
/**
 * 事件处理配置
 * <p>
 * 配置异步事件处理的线程池和重试机制。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Configuration
@EnableAsync
public class EventHandlingConfig {
    
    /**
     * 事件处理线程池
     */
    @Bean("eventHandlingExecutor")
    public Executor eventHandlingExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("event-handler-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
    
    /**
     * 事件处理重试模板
     */
    @Bean
    public RetryTemplate eventRetryTemplate() {
        RetryTemplate retryTemplate = new RetryTemplate();
        
        // 重试策略：最多重试3次，间隔1秒
        FixedBackOffPolicy backOffPolicy = new FixedBackOffPolicy();
        backOffPolicy.setBackOffPeriod(1000);
        retryTemplate.setBackOffPolicy(backOffPolicy);
        
        SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy();
        retryPolicy.setMaxAttempts(3);
        retryTemplate.setRetryPolicy(retryPolicy);
        
        return retryTemplate;
    }
}
```

#### 事件发布时机和方式

**1. 在应用服务中发布事件**

```java
@Service
@Transactional(rollbackFor = Exception.class)
public class UserApplicationService {
    
    private final UserRepository userRepository;
    private final DomainEventPublisher eventPublisher;
    
    public UserApplicationService(UserRepository userRepository, 
                                DomainEventPublisher eventPublisher) {
        this.userRepository = userRepository;
        this.eventPublisher = eventPublisher;
    }
    
    /**
     * 创建用户
     */
    public String createUser(CreateUserCommand command) {
        // 1. 创建用户实体
        User user = User.create(command.getUsername(), command.getEmail(), command.getPassword());
        
        // 2. 保存用户
        userRepository.save(user);
        
        // 3. 发布领域事件（在事务提交后）
        eventPublisher.publishEvents(user);
        
        return user.getId();
    }
}
```

**2. 使用 @TransactionalEventListener 确保事务一致性**

```java
@Component
public class UserCreatedEventHandler {
    
    /**
     * 在事务提交后处理事件
     */
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    @Async
    public void handleUserCreated(UserCreatedEvent event) {
        // 事件处理逻辑
        // 只有在事务成功提交后才会执行
    }
    
    /**
     * 在事务回滚后处理事件
     */
    @TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)
    public void handleUserCreationFailed(UserCreatedEvent event) {
        // 处理事务回滚后的清理工作
    }
}
```

#### 事件处理幂等性

```java
/**
 * 幂等性事件处理器
 * <p>
 * 确保事件处理的幂等性，避免重复处理。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class IdempotentUserCreatedEventHandler {
    
    private final RedisTemplate<String, String> redisTemplate;
    private final Logger logger = LoggerFactory.getLogger(IdempotentUserCreatedEventHandler.class);
    
    @EventListener
    @Async
    public void handle(UserCreatedEvent event) {
        String eventKey = "event:processed:" + event.getEventId();
        
        // 检查事件是否已经处理过
        if (Boolean.TRUE.equals(redisTemplate.hasKey(eventKey))) {
            logger.warn("事件已处理，跳过: {}", event);
            return;
        }
        
        try {
            // 处理事件
            processUserCreated(event);
            
            // 标记事件已处理（设置过期时间防止内存泄漏）
            redisTemplate.opsForValue().set(eventKey, "processed", Duration.ofDays(7));
            
        } catch (Exception e) {
            logger.error("处理用户创建事件失败: {}", event, e);
            throw e;
        }
    }
    
    private void processUserCreated(UserCreatedEvent event) {
        // 具体的事件处理逻辑
    }
}
```

#### 事件处理监控和告警

```java
/**
 * 事件处理监控
 * <p>
 * 监控事件处理的成功率和性能。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class EventHandlingMonitor {
    
    private final MeterRegistry meterRegistry;
    private final Logger logger = LoggerFactory.getLogger(EventHandlingMonitor.class);
    
    public EventHandlingMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    /**
     * 记录事件处理成功
     */
    public void recordSuccess(String eventType, long processingTime) {
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("event.processing.time")
                .tag("event.type", eventType)
                .tag("status", "success")
                .register(meterRegistry));
        
        meterRegistry.counter("event.processing.count", 
                            "event.type", eventType, 
                            "status", "success").increment();
    }
    
    /**
     * 记录事件处理失败
     */
    public void recordFailure(String eventType, String errorType) {
        meterRegistry.counter("event.processing.count", 
                            "event.type", eventType, 
                            "status", "failure",
                            "error.type", errorType).increment();
        
        // 发送告警
        sendAlert(eventType, errorType);
    }
    
    private void sendAlert(String eventType, String errorType) {
        logger.error("事件处理失败告警: eventType={}, errorType={}", eventType, errorType);
        // 这里可以集成告警系统，如钉钉、邮件等
    }
}
```

#### 事件处理死信队列

```java
/**
 * 死信队列处理器
 * <p>
 * 处理多次重试失败的事件。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class DeadLetterEventHandler {
    
    private final Logger logger = LoggerFactory.getLogger(DeadLetterEventHandler.class);
    private final EventStore eventStore;
    
    public DeadLetterEventHandler(EventStore eventStore) {
        this.eventStore = eventStore;
    }
    
    /**
     * 处理死信事件
     */
    public void handleDeadLetterEvent(DomainEvent<?> event, Exception lastException) {
        logger.error("事件处理最终失败，进入死信队列: event={}, error={}", event, lastException.getMessage());
        
        // 保存到死信表
        saveToDeadLetterTable(event, lastException);
        
        // 发送告警
        sendDeadLetterAlert(event, lastException);
    }
    
    private void saveToDeadLetterTable(DomainEvent<?> event, Exception exception) {
        // 保存到死信表的逻辑
        // 可以包含事件内容、失败原因、重试次数等信息
    }
    
    private void sendDeadLetterAlert(DomainEvent<?> event, Exception exception) {
        // 发送死信告警
        logger.error("死信事件告警: eventId={}, eventType={}, error={}", 
                   event.getEventId(), event.getClass().getSimpleName(), exception.getMessage());
    }
}
```

### 3.7.6 事件使用指南

#### 何时使用领域事件

1. **聚合间通信**：当一个聚合的状态变化需要影响其他聚合时
2. **解耦业务逻辑**：将主要业务逻辑与次要业务逻辑分离
3. **异步处理**：处理耗时的操作，如发送邮件、调用外部服务
4. **审计日志**：记录重要的业务状态变化
5. **最终一致性**：在分布式系统中实现最终一致性

#### 事件设计原则

1. **业务语义**：事件名称应该反映业务含义，使用过去时态
2. **不可变性**：事件一旦创建就不能修改
3. **完整信息**：事件应该包含处理所需的所有信息
4. **版本兼容**：考虑事件的向前和向后兼容性
5. **幂等处理**：事件处理应该是幂等的

#### 事件处理注意事项

1. **异常处理**：妥善处理事件处理中的异常，避免影响主流程
2. **性能考虑**：避免在事件处理中执行耗时操作
3. **事务边界**：明确事件发布和处理的事务边界
4. **顺序保证**：如果需要保证事件处理顺序，需要特殊设计
5. **监控告警**：建立完善的监控和告警机制

#### 事件处理模式

**1. 发布-订阅模式**
```java
// 一个事件可以有多个处理器
@EventListener
public void handleUserCreated1(UserCreatedEvent event) { /* 处理逻辑1 */ }

@EventListener
public void handleUserCreated2(UserCreatedEvent event) { /* 处理逻辑2 */ }
```

**2. 事件链模式**
```java
// 事件处理器可以发布新的事件
@EventListener
public void handleUserCreated(UserCreatedEvent event) {
    // 处理用户创建
    // ...
    
    // 发布新事件
    eventPublisher.publish(new UserWelcomeEmailSentEvent(event.getAggregateId()));
}
```

**3. 事件聚合模式**
```java
// 聚合多个相关事件进行批量处理
@EventListener
public void handleUserEvents(List<UserEvent> events) {
    // 批量处理用户相关事件
}
```

## 3.8 异常设计

### 3.8.1 领域异常

```java
/**
 * 领域异常
 * <p>
 * 表示领域层的业务规则违反异常。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class DomainException extends RuntimeException {
    
    public DomainException(String message) {
        super(message);
    }
    
    public DomainException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

## 3.9 最佳实践

### 3.9.1 领域模型设计原则

1. **充血模型**：实体应该包含业务行为，而不仅仅是数据容器
2. **封装性**：隐藏内部实现细节，只暴露必要的业务接口
3. **不变性**：值对象应该是不可变的
4. **业务语言**：使用业务术语命名类和方法
5. **单一职责**：每个领域对象都有明确的业务职责

### 3.9.2 聚合设计原则

1. **小聚合**：聚合应该尽可能小，只包含必要的对象
2. **一致性边界**：聚合是事务一致性的边界
3. **通过ID引用**：聚合间通过ID引用，而不是对象引用
4. **聚合根控制**：只能通过聚合根访问聚合内部对象

### 3.9.3 领域事件使用指南

1. **业务意义**：事件应该表达有业务意义的状态变化
2. **不可变性**：事件一旦创建就不能修改
3. **异步处理**：事件处理应该是异步的
4. **幂等性**：事件处理应该是幂等的

## 3.10 总结

领域层是DDD分层架构的核心，它封装了业务的核心逻辑和规则。通过合理的设计实体、值对象、聚合、领域服务等组件，我们可以构建出高质量、可维护的领域模型。

**关键要点：**
- 领域层不依赖任何技术框架
- 实体包含业务行为，不仅仅是数据容器
- 值对象是不可变的，通过属性值判断相等性
- 聚合是一致性边界，通过聚合根控制访问
- 领域事件用于解耦和异步处理
- 仓储接口定义数据访问契约，具体实现在基础设施层

在下一章中，我们将介绍应用层的设计和实现，看看如何编排领域对象完成业务用例。