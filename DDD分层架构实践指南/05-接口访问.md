# 5. 接口访问层设计与实现

## 5.1 接口层概述

接口访问层是领域驱动设计（DDD）分层架构中最外层的部分，负责处理来自外部的请求，并将其转发给应用层进行处理。接口层是系统与外部世界交互的边界，包括用户界面、API接口、消息队列等多种形式。

### 5.1.1 接口层的定位

在DDD分层架构中，接口层的定位如下：

```
接口层 → 应用层 → 领域层 → 基础设施层
```

- **接口层**：负责处理外部请求，转发给应用层
- **应用层**：协调和编排领域对象，处理用例流程
- **领域层**：包含业务逻辑和规则，是系统的核心
- **基础设施层**：提供技术支持，如持久化、消息传递等

### 5.1.2 接口层的职责边界

接口层的主要职责是：

1. **请求接收**：接收来自外部的请求
2. **参数解析**：解析请求参数
3. **参数验证**：验证请求参数的合法性
4. **权限检查**：检查请求者的权限
5. **请求转发**：将请求转发给应用层
6. **结果封装**：将应用层的处理结果封装为响应
7. **异常处理**：处理请求过程中的异常

接口层不应该包含：

1. **业务逻辑**：业务逻辑应该在领域层中实现
2. **用例编排**：用例编排应该在应用层中实现
3. **持久化逻辑**：持久化应该由基础设施层处理

## 5.2 接口层核心职责

### 5.2.1 请求接收与参数解析

接口层负责接收来自外部的请求，并解析请求参数。在Spring MVC中，通常使用`@RequestMapping`、`@GetMapping`、`@PostMapping`等注解来定义请求处理方法。

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping
    public ResponseEntity<UserResponse> createUser(@RequestBody CreateUserRequest request) {
        // 处理创建用户请求
    }
    
    @GetMapping("/{userId}")
    public ResponseEntity<UserResponse> getUser(@PathVariable String userId) {
        // 处理获取用户请求
    }
}
```

### 5.2.2 参数验证

接口层负责验证请求参数的合法性，确保参数符合业务规则。在Spring MVC中，通常使用Bean Validation来验证请求参数。

```java
@PostMapping
public ResponseEntity<UserResponse> createUser(@Valid @RequestBody CreateUserRequest request) {
    // 处理创建用户请求
}
```

请求对象中定义验证规则：

```java
public class CreateUserRequest {
    
    @NotBlank(message = "用户名不能为空")
    @Size(min = 4, max = 20, message = "用户名长度必须在4-20之间")
    private String username;
    
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;
    
    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20之间")
    private String password;
    
    // getter 和 setter 方法...
}
```

### 5.2.3 权限检查

接口层负责检查请求者的权限，确保请求者有权限执行请求的操作。在Spring Security中，通常使用`@PreAuthorize`注解来定义权限检查规则。

```java
@GetMapping("/{userId}")
@PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")
public ResponseEntity<UserResponse> getUser(@PathVariable String userId) {
    // 处理获取用户请求
}
```

### 5.2.4 请求转发

接口层负责将请求转发给应用层，调用应用服务的方法处理请求。

```java
@PostMapping
public ResponseEntity<UserResponse> createUser(@Valid @RequestBody CreateUserRequest request) {
    // 将请求参数转换为命令对象
    CreateUserCommand command = requestMapper.toCommand(request);
    
    // 调用应用服务处理请求
    String userId = userApplicationService.createUser(command);
    
    // 返回处理结果
    return ResponseEntity.created(URI.create("/api/users/" + userId))
        .body(new UserResponse(userId));
}
```

### 5.2.5 结果封装

接口层负责将应用层的处理结果封装为响应，返回给请求者。

```java
@GetMapping("/{userId}")
public ResponseEntity<UserResponse> getUser(@PathVariable String userId) {
    // 调用应用服务获取用户信息
    UserDTO userDTO = userApplicationService.getUser(userId);
    
    // 将DTO转换为响应对象
    UserResponse response = responseMapper.toResponse(userDTO);
    
    // 返回响应
    return ResponseEntity.ok(response);
}
```

### 5.2.6 异常处理

接口层负责处理请求过程中的异常，将异常转换为合适的HTTP响应。在Spring MVC中，通常使用`@ExceptionHandler`注解来定义异常处理方法。

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleEntityNotFoundException(EntityNotFoundException e) {
        ErrorResponse response = new ErrorResponse(e.getErrorCode(), e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }
    
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException e) {
        ErrorResponse response = new ErrorResponse(e.getErrorCode(), e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException e) {
        List<String> errors = e.getBindingResult().getFieldErrors().stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .collect(Collectors.toList());
        
        ErrorResponse response = new ErrorResponse("VALIDATION_ERROR", "参数验证失败", errors);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }
}
```

## 5.3 接口层设计原则

### 5.3.1 关注点分离原则

接口层应该只关注接口相关的逻辑，不应该包含业务逻辑。业务逻辑应该由应用层和领域层处理。

### 5.3.2 接口一致性原则

接口设计应该保持一致性，包括URL命名、请求方法、请求参数、响应格式等。

### 5.3.3 版本控制原则

接口应该支持版本控制，以便在接口变更时保持向后兼容性。

```java
@RestController
@RequestMapping("/api/v1/users")
public class UserControllerV1 {
    // V1版本的接口实现
}

@RestController
@RequestMapping("/api/v2/users")
public class UserControllerV2 {
    // V2版本的接口实现
}
```

### 5.3.4 安全性原则

接口设计应该考虑安全性，包括认证、授权、数据加密等。

### 5.3.5 可测试性原则

接口设计应该考虑可测试性，便于进行单元测试和集成测试。

## 5.4 REST API设计

### 5.4.1 资源命名

资源应该使用名词复数形式，例如`/users`、`/orders`。

### 5.4.2 HTTP方法

使用HTTP方法表示对资源的操作：

- **GET**：获取资源
- **POST**：创建资源
- **PUT**：更新资源（全量更新）
- **PATCH**：更新资源（部分更新）
- **DELETE**：删除资源

### 5.4.3 URL设计

- **获取资源列表**：GET /resources
- **获取单个资源**：GET /resources/{id}
- **创建资源**：POST /resources
- **更新资源**：PUT /resources/{id} 或 PATCH /resources/{id}
- **删除资源**：DELETE /resources/{id}
- **获取子资源**：GET /resources/{id}/sub-resources
- **创建子资源**：POST /resources/{id}/sub-resources

### 5.4.4 查询参数

使用查询参数进行过滤、排序、分页等操作：

- **过滤**：/users?status=active
- **排序**：/users?sort=username,asc
- **分页**：/users?page=1&size=10

### 5.4.5 状态码

使用合适的HTTP状态码表示请求处理结果：

- **200 OK**：请求成功
- **201 Created**：资源创建成功
- **204 No Content**：请求成功，但没有返回内容
- **400 Bad Request**：请求参数错误
- **401 Unauthorized**：未认证
- **403 Forbidden**：没有权限
- **404 Not Found**：资源不存在
- **409 Conflict**：资源冲突
- **500 Internal Server Error**：服务器内部错误

### 5.4.6 响应格式

响应应该使用统一的格式，例如成功响应：

```json
{
  "success": true,
  "code": "SUCCESS",
  "message": "操作成功",
  "data": {
    "id": "123",
    "username": "john",
    "email": "john@example.com"
  },
  "details": null,
  "timestamp": 1625097600000
}
```

错误响应：

```json
{
  "success": false,
  "code": "VALIDATION_ERROR",
  "message": "参数验证失败",
  "data": null,
  "details": [
    "username: 用户名不能为空",
    "email: 邮箱格式不正确"
  ],
  "timestamp": 1625097600000
}
```

## 5.5 用户控制器设计

以用户管理为例，设计用户控制器。

### 5.5.1 用户控制器

```java
/**
 * 用户控制器
 * <p>
 * 提供用户管理相关的REST API，包括用户创建、查询、更新等操作。
 * 使用统一的ApiResponse对象封装响应。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserApplicationService userApplicationService;
    private final RequestMapper requestMapper;
    private final ResponseMapper responseMapper;
    
    public UserController(UserApplicationService userApplicationService,
                         RequestMapper requestMapper,
                         ResponseMapper responseMapper) {
        this.userApplicationService = userApplicationService;
        this.requestMapper = requestMapper;
        this.responseMapper = responseMapper;
    }
    
    /**
     * 创建用户
     *
     * @param request 创建用户请求
     * @return 统一API响应
     */
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public ApiResponse<UserResponse> createUser(@Valid @RequestBody CreateUserRequest request) {
        // 将请求参数转换为命令对象
        CreateUserCommand command = requestMapper.toCommand(request);
        
        // 调用应用服务处理请求
        String userId = userApplicationService.createUser(command);
        
        // 获取创建的用户信息
        UserDTO userDTO = userApplicationService.getUser(userId);
        
        // 将DTO转换为响应对象
        UserResponse response = responseMapper.toResponse(userDTO);
        
        // 返回处理结果
        return ApiResponse.success("用户创建成功", response);
    }
    
    /**
     * 获取用户详情
     *
     * @param userId 用户ID
     * @return 统一API响应
     */
    @GetMapping("/{userId}")
    @PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")
    public ApiResponse<UserResponse> getUser(@PathVariable String userId) {
        // 调用应用服务获取用户信息
        UserDTO userDTO = userApplicationService.getUser(userId);
        
        // 将DTO转换为响应对象
        UserResponse response = responseMapper.toResponse(userDTO);
        
        // 返回响应
        return ApiResponse.success(response);
    }
    
    /**
     * 更新用户邮箱
     *
     * @param userId 用户ID
     * @param request 更新邮箱请求
     * @return 统一API响应
     */
    @PutMapping("/{userId}/email")
    @PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")
    public ApiResponse<Void> updateEmail(@PathVariable String userId,
                                       @Valid @RequestBody UpdateEmailRequest request) {
        // 将请求参数转换为命令对象
        UpdateEmailCommand command = requestMapper.toCommand(userId, request);
        
        // 调用应用服务处理请求
        userApplicationService.updateEmail(command);
        
        // 返回处理结果
        return ApiResponse.success("邮箱更新成功", null);
    }
    
    /**
     * 更新用户密码
     *
     * @param userId 用户ID
     * @param request 更新密码请求
     * @return 统一API响应
     */
    @PutMapping("/{userId}/password")
    @PreAuthorize("#userId == authentication.principal.id")
    public ApiResponse<Void> updatePassword(@PathVariable String userId,
                                          @Valid @RequestBody UpdatePasswordRequest request) {
        // 将请求参数转换为命令对象
        UpdatePasswordCommand command = requestMapper.toCommand(userId, request);
        
        // 调用应用服务处理请求
        userApplicationService.updatePassword(command);
        
        // 返回处理结果
        return ApiResponse.success("密码更新成功", null);
    }
    
    /**
     * 激活用户
     *
     * @param userId 用户ID
     * @return 空响应
     */
    @PutMapping("/{userId}/activation")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> activateUser(@PathVariable String userId) {
        // 调用应用服务处理请求
        userApplicationService.activateUser(userId);
        
        // 返回处理结果
        return ResponseEntity.noContent().build();
    }
    
    /**
     * 停用用户
     *
     * @param userId 用户ID
     * @return 空响应
     */
    @DeleteMapping("/{userId}/activation")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> deactivateUser(@PathVariable String userId) {
        // 调用应用服务处理请求
        userApplicationService.deactivateUser(userId);
        
        // 返回处理结果
        return ResponseEntity.noContent().build();
    }
    
    /**
     * 查询用户列表
     *
     * @param username 用户名（可选）
     * @param email 邮箱（可选）
     * @param status 状态（可选）
     * @param pageable 分页参数
     * @return 用户列表响应
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PageResponse<UserResponse>> findUsers(
        @RequestParam(required = false) String username,
        @RequestParam(required = false) String email,
        @RequestParam(required = false) UserStatus status,
        Pageable pageable) {
        
        // 构建查询条件
        UserQuery query = new UserQuery();
        query.setUsername(username);
        query.setEmail(email);
        query.setStatus(status);
        query.setPage(pageable.getPageNumber());
        query.setSize(pageable.getPageSize());
        query.setSort(pageable.getSort().toString());
        
        // 调用应用服务查询用户列表
        List<UserDTO> userDTOs = userApplicationService.findUsers(query);
        
        // 将DTO列表转换为响应对象列表
        List<UserResponse> responses = userDTOs.stream()
            .map(responseMapper::toResponse)
            .collect(Collectors.toList());
        
        // 构建分页响应
        PageResponse<UserResponse> pageResponse = new PageResponse<>(responses, pageable, userDTOs.size());
        
        // 返回响应
        return ResponseEntity.ok(pageResponse);
    }
}
```

## 5.6 请求/响应对象设计

### 5.6.1 基础请求/响应对象

```java
/**
 * 基础请求对象
 * <p>
 * 所有请求对象的基类，提供通用属性和方法。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public abstract class BaseRequest implements Serializable {
    // 通用属性和方法...
}

/**
 * 基础响应对象
 * <p>
 * 所有响应对象的基类，提供通用属性和方法。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public abstract class BaseResponse implements Serializable {
    
    /** 创建时间 */
    private LocalDateTime createdTime;
    
    /** 更新时间 */
    private LocalDateTime updatedTime;
    
    // getter 和 setter 方法...
}
```

### 5.6.2 创建用户请求/响应

```java
/**
 * 创建用户请求
 * <p>
 * 封装创建用户所需的数据。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class CreateUserRequest extends BaseRequest {
    
    /** 用户名 */
    @NotBlank(message = "用户名不能为空")
    @Size(min = 4, max = 20, message = "用户名长度必须在4-20之间")
    private String username;
    
    /** 邮箱 */
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;
    
    /** 密码 */
    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20之间")
    private String password;
    
    // getter 和 setter 方法...
}

/**
 * 用户响应
 * <p>
 * 封装用户信息，用于返回给客户端。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UserResponse extends BaseResponse {
    
    /** 用户ID */
    private String id;
    
    /** 用户名 */
    private String username;
    
    /** 邮箱 */
    private String email;
    
    /** 用户状态 */
    private UserStatus status;
    
    /** 最后登录时间 */
    private LocalDateTime lastLoginTime;
    
    // getter 和 setter 方法...
}
```

### 5.6.3 更新邮箱请求

```java
/**
 * 更新邮箱请求
 * <p>
 * 封装更新用户邮箱所需的数据。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UpdateEmailRequest extends BaseRequest {
    
    /** 新邮箱 */
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;
    
    // getter 和 setter 方法...
}
```

### 5.6.4 更新密码请求

```java
/**
 * 更新密码请求
 * <p>
 * 封装更新用户密码所需的数据。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class UpdatePasswordRequest extends BaseRequest {
    
    /** 旧密码 */
    @NotBlank(message = "旧密码不能为空")
    private String oldPassword;
    
    /** 新密码 */
    @NotBlank(message = "新密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20之间")
    private String newPassword;
    
    // getter 和 setter 方法...
}
```

### 5.6.5 统一响应对象设计

```java
/**
 * 统一API响应对象
 * <p>
 * 封装所有API响应的标准格式，包括成功响应和错误响应。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class ApiResponse<T> implements Serializable {
    
    /** 是否成功 */
    private boolean success;
    
    /** 状态码 */
    private String code;
    
    /** 消息 */
    private String message;
    
    /** 数据 */
    private T data;
    
    /** 错误详情 */
    private List<String> details;
    
    /** 时间戳 */
    private long timestamp;
    
    /**
     * 私有构造函数
     */
    private ApiResponse() {
        this.timestamp = System.currentTimeMillis();
    }
    
    /**
     * 创建成功响应
     *
     * @param <T> 数据类型
     * @return 成功响应
     */
    public static <T> ApiResponse<T> success() {
        ApiResponse<T> response = new ApiResponse<>();
        response.success = true;
        response.code = "SUCCESS";
        response.message = "操作成功";
        return response;
    }
    
    /**
     * 创建成功响应
     *
     * @param data 数据
     * @param <T> 数据类型
     * @return 成功响应
     */
    public static <T> ApiResponse<T> success(T data) {
        ApiResponse<T> response = success();
        response.data = data;
        return response;
    }
    
    /**
     * 创建成功响应
     *
     * @param message 消息
     * @param data 数据
     * @param <T> 数据类型
     * @return 成功响应
     */
    public static <T> ApiResponse<T> success(String message, T data) {
        ApiResponse<T> response = success(data);
        response.message = message;
        return response;
    }
    
    /**
     * 创建错误响应
     *
     * @param code 错误码
     * @param message 错误消息
     * @param <T> 数据类型
     * @return 错误响应
     */
    public static <T> ApiResponse<T> error(String code, String message) {
        ApiResponse<T> response = new ApiResponse<>();
        response.success = false;
        response.code = code;
        response.message = message;
        return response;
    }
    
    /**
     * 创建错误响应
     *
     * @param code 错误码
     * @param message 错误消息
     * @param details 错误详情
     * @param <T> 数据类型
     * @return 错误响应
     */
    public static <T> ApiResponse<T> error(String code, String message, List<String> details) {
        ApiResponse<T> response = error(code, message);
        response.details = details;
        return response;
    }
    
    // getter 方法...
    public boolean isSuccess() {
        return success;
    }
    
    public String getCode() {
        return code;
    }
    
    public String getMessage() {
        return message;
    }
    
    public T getData() {
        return data;
    }
    
    public List<String> getDetails() {
        return details;
    }
    
    public long getTimestamp() {
        return timestamp;
    }
}
```

## 5.7 请求/响应映射器

### 5.7.1 请求映射器

```java
/**
 * 请求映射器
 * <p>
 * 负责将请求对象转换为命令对象。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class RequestMapper {
    
    /**
     * 将创建用户请求转换为创建用户命令
     *
     * @param request 创建用户请求
     * @return 创建用户命令
     */
    public CreateUserCommand toCommand(CreateUserRequest request) {
        if (request == null) {
            return null;
        }
        
        CreateUserCommand command = new CreateUserCommand();
        command.setUsername(request.getUsername());
        command.setEmail(request.getEmail());
        command.setPassword(request.getPassword());
        
        return command;
    }
    
    /**
     * 将更新邮箱请求转换为更新邮箱命令
     *
     * @param userId 用户ID
     * @param request 更新邮箱请求
     * @return 更新邮箱命令
     */
    public UpdateEmailCommand toCommand(String userId, UpdateEmailRequest request) {
        if (request == null) {
            return null;
        }
        
        UpdateEmailCommand command = new UpdateEmailCommand();
        command.setUserId(userId);
        command.setEmail(request.getEmail());
        
        return command;
    }
    
    /**
     * 将更新密码请求转换为更新密码命令
     *
     * @param userId 用户ID
     * @param request 更新密码请求
     * @return 更新密码命令
     */
    public UpdatePasswordCommand toCommand(String userId, UpdatePasswordRequest request) {
        if (request == null) {
            return null;
        }
        
        UpdatePasswordCommand command = new UpdatePasswordCommand();
        command.setUserId(userId);
        command.setOldPassword(request.getOldPassword());
        command.setNewPassword(request.getNewPassword());
        
        return command;
    }
}
```

### 5.7.2 响应映射器

```java
/**
 * 响应映射器
 * <p>
 * 负责将DTO对象转换为响应对象。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class ResponseMapper {
    
    /**
     * 将用户DTO转换为用户响应
     *
     * @param dto 用户DTO
     * @return 用户响应
     */
    public UserResponse toResponse(UserDTO dto) {
        if (dto == null) {
            return null;
        }
        
        UserResponse response = new UserResponse();
        response.setId(dto.getId());
        response.setUsername(dto.getUsername());
        response.setEmail(dto.getEmail());
        response.setStatus(dto.getStatus());
        response.setLastLoginTime(dto.getLastLoginTime());
        response.setCreatedTime(dto.getCreatedTime());
        response.setUpdatedTime(dto.getUpdatedTime());
        
        return response;
    }
}
```

## 5.8 全局异常处理

```java
/**
 * 全局异常处理器
 * <p>
 * 处理系统中的异常，将其转换为统一的API响应。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    /**
     * 处理实体未找到异常
     *
     * @param e 实体未找到异常
     * @return 统一API响应
     */
    @ExceptionHandler(EntityNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ApiResponse<Void> handleEntityNotFoundException(EntityNotFoundException e) {
        logger.warn("实体未找到: {}", e.getMessage());
        return ApiResponse.error(e.getErrorCode(), e.getMessage());
    }
    
    /**
     * 处理业务异常
     *
     * @param e 业务异常
     * @return 统一API响应
     */
    @ExceptionHandler(BusinessException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ApiResponse<Void> handleBusinessException(BusinessException e) {
        logger.warn("业务异常: {}", e.getMessage());
        return ApiResponse.error(e.getErrorCode(), e.getMessage());
    }
    
    /**
     * 处理参数验证异常
     *
     * @param e 参数验证异常
     * @return 统一API响应
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ApiResponse<Void> handleValidationException(MethodArgumentNotValidException e) {
        List<String> errors = e.getBindingResult().getFieldErrors().stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .collect(Collectors.toList());
        
        logger.warn("参数验证失败: {}", errors);
        return ApiResponse.error("VALIDATION_ERROR", "参数验证失败", errors);
    }
    
    /**
     * 处理访问拒绝异常
     *
     * @param e 访问拒绝异常
     * @return 统一API响应
     */
    @ExceptionHandler(AccessDeniedException.class)
    @ResponseStatus(HttpStatus.FORBIDDEN)
    public ApiResponse<Void> handleAccessDeniedException(AccessDeniedException e) {
        logger.warn("访问拒绝: {}", e.getMessage());
        return ApiResponse.error("ACCESS_DENIED", "没有权限访问该资源");
    }
    
    /**
     * 处理未认证异常
     *
     * @param e 未认证异常
     * @return 统一API响应
     */
    @ExceptionHandler(AuthenticationException.class)
    @ResponseStatus(HttpStatus.UNAUTHORIZED)
    public ApiResponse<Void> handleAuthenticationException(AuthenticationException e) {
        logger.warn("未认证: {}", e.getMessage());
        return ApiResponse.error("UNAUTHORIZED", "未认证或认证已过期");
    }
    
    /**
     * 处理其他异常
     *
     * @param e 其他异常
     * @return 统一API响应
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ApiResponse<Void> handleException(Exception e) {
        logger.error("系统异常", e);
        return ApiResponse.error("INTERNAL_ERROR", "系统内部错误");
    }
}
```

## 5.11 最佳实践

### 5.11.1 接口设计最佳实践

1. **使用RESTful风格**：遵循REST原则设计API
2. **版本控制**：在URL中包含版本号，例如`/api/v1/users`
3. **使用HTTP方法**：使用GET、POST、PUT、PATCH、DELETE表示操作
4. **使用HTTP状态码**：使用合适的HTTP状态码表示请求处理结果
5. **使用查询参数**：使用查询参数进行过滤、排序、分页等操作
6. **使用统一的响应格式**：使用统一的响应格式，包括成功响应和错误响应
7. **使用JSON格式**：使用JSON作为请求和响应的数据格式
8. **使用驼峰命名**：使用驼峰命名法命名JSON字段
9. **使用复数名词**：使用复数名词命名资源，例如`/users`而不是`/user`
10. **使用嵌套资源**：使用嵌套资源表示资源之间的关系，例如`/users/{id}/orders`

### 5.11.2 安全最佳实践

1. **使用HTTPS**：使用HTTPS加密传输数据
2. **使用JWT**：使用JWT进行认证和授权
3. **使用密码加密**：使用BCrypt等算法加密密码
4. **使用CSRF保护**：使用CSRF令牌防止跨站请求伪造
5. **使用XSS保护**：使用XSS过滤器防止跨站脚本攻击
6. **使用CORS**：使用CORS控制跨域访问
7. **使用速率限制**：使用速率限制防止暴力攻击
8. **使用输入验证**：验证所有输入参数，防止注入攻击
9. **使用最小权限原则**：只授予必要的权限
10. **使用安全头**：使用安全头防止点击劫持等攻击

### 5.11.3 性能最佳实践

1. **使用缓存**：使用缓存减少数据库访问
2. **使用分页**：使用分页减少数据传输量
3. **使用压缩**：使用GZIP等压缩算法减少数据传输量
4. **使用异步处理**：使用异步处理提高响应速度
5. **使用连接池**：使用连接池减少连接创建开销
6. **使用索引**：使用索引提高查询性能
7. **使用批处理**：使用批处理减少数据库访问次数
8. **使用延迟加载**：使用延迟加载减少不必要的数据加载
9. **使用CDN**：使用CDN加速静态资源访问
10. **使用负载均衡**：使用负载均衡分散请求压力

## 5.12 总结

接口层是系统与外部世界交互的边界，负责处理来自外部的请求，并将其转发给应用层进行处理。接口层的设计应该遵循关注点分离、接口一致性、版本控制等原则，保持接口层轻量级，将业务逻辑委派给应用层处理。

接口层的核心组件包括控制器、请求/响应对象、请求/响应映射器、异常处理器等。控制器接收请求并调用应用服务，请求/响应对象封装请求和响应数据，请求/响应映射器在请求/响应对象和命令/DTO对象之间进行转换，异常处理器处理请求过程中的异常。

通过合理设计接口层，可以实现系统与外部世界的解耦，提高系统的可维护性和可扩展性。