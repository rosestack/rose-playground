# 6. 基础设施层

## 6.1 基础设施层概述

### 6.1.1 定位与职责边界

基础设施层是DDD分层架构中的最底层，负责提供技术实现和外部依赖集成，支撑上层应用的运行。它是连接领域层与外部世界的桥梁，实现领域层定义的技术抽象接口。

基础设施层的核心职责包括：

1. **持久化实现**：实现领域层定义的仓储接口，提供数据存储和查询能力
2. **外部服务集成**：集成第三方服务和API，如支付网关、短信服务等
3. **技术框架配置**：配置和管理技术框架，如数据库连接池、缓存等
4. **横切关注点实现**：实现日志、监控、安全等横切关注点
5. **消息队列集成**：实现消息的发布和订阅
6. **领域事件发布器实现**：实现领域事件的发布和处理机制
7. **缓存实现**：提供缓存服务，提高系统性能

### 6.1.2 与其他层的关系

基础设施层与其他层的关系如下：

1. **与领域层的关系**：基础设施层实现领域层定义的接口，如仓储接口、领域事件发布器接口等，遵循依赖倒置原则
2. **与应用层的关系**：应用层通过领域层定义的接口间接使用基础设施层的功能，不直接依赖基础设施层的具体实现
3. **与接口层的关系**：接口层通常不直接访问基础设施层，而是通过应用层间接使用

### 6.1.3 设计原则

基础设施层的设计应遵循以下原则：

1. **依赖倒置原则**：实现领域层定义的接口，而不是让领域层依赖基础设施层
2. **关注点分离原则**：将不同的技术关注点分离到不同的组件中
3. **可替换性原则**：设计应支持不同技术实现的替换，如数据库、消息队列等
4. **封装变化原则**：封装可能变化的技术细节，减少变化对系统的影响
5. **最小知识原则**：基础设施层组件只暴露必要的接口，隐藏实现细节

## 6.2 数据库访问实现

### 6.2.1 数据库访问概述

数据库访问是基础设施层的核心职责之一，负责与数据库交互，实现数据的持久化和查询。在本项目中，我们使用MyBatis-Plus作为ORM框架，实现数据库访问。

数据库访问实现通常包括以下组件：

1. **数据源配置**：配置数据库连接池和数据源
2. **MyBatis-Plus配置**：配置MyBatis-Plus的全局设置、插件和类型处理器
3. **数据访问对象（Mapper）**：定义数据库操作接口
4. **数据库迁移**：使用Flyway或Liquibase管理数据库版本

### 6.2.2 数据源配置

使用HikariCP作为连接池，配置数据源：
> **配置说明：**
> - **字符集**：使用 `utf8mb4` 支持完整的 Unicode 字符集，包括 Emoji
> - **超时设置**：包含连接超时和Socket超时配置
> - **连接池**：HikariCP 核心配置，适合大多数应用场景
> - **批量优化**：启用 `rewriteBatchedStatements` 提升批量操作性能

```yaml
spring:
  datasource:
    # MySQL 8.0 驱动
    driver-class-name: com.mysql.cj.jdbc.Driver
    # 数据库连接URL - 核心必要参数
    url: jdbc:mysql://localhost:3306/rose_db?useUnicode=true&characterEncoding=utf8mb4&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true&connectTimeout=10000&socketTimeout=30000&rewriteBatchedStatements=true
    # 数据库用户名 - 支持环境变量覆盖
    username: ${DB_USERNAME:root}
    # 数据库密码 - 支持环境变量覆盖
    password: ${DB_PASSWORD:password}

    # HikariCP 连接池配置
    hikari:
      # 连接池名称
      pool-name: HikariCP-DDD-Demo
      # 最小空闲连接数
      minimum-idle: 5
      # 最大连接池大小
      maximum-pool-size: 20
      # 连接超时时间 (30秒)
      connection-timeout: 30000
      # 空闲连接超时时间 (10分钟)
      idle-timeout: 600000
      # 连接最大生命周期 (30分钟)
      max-lifetime: 1800000
      # 连接有效性检测查询
      connection-test-query: SELECT 1
      # 开启连接泄漏检测 (1分钟)
      leak-detection-threshold: 60000
```

**不同环境的配置调整：**

```yaml
# application-dev.yml - 开发环境
spring:
  datasource:
    hikari:
      # 开发环境使用较小的连接池
      minimum-idle: 2
      maximum-pool-size: 10
      # 开启连接泄漏检测 (1分钟)
      leak-detection-threshold: 60000

---
# application-test.yml - 测试环境
spring:
  datasource:
    hikari:
      # 测试环境中等连接池
      minimum-idle: 3
      maximum-pool-size: 15
      # 较短的连接生命周期
      max-lifetime: 900000

---
# application-prod.yml - 生产环境
spring:
  datasource:
    hikari:
      # 生产环境大连接池
      minimum-idle: 10
      maximum-pool-size: 50
      # 关闭连接泄漏检测以提高性能
      leak-detection-threshold: 0
      # 更长的连接生命周期
      max-lifetime: 3600000
```

### 6.2.3 MyBatis-Plus配置

配置MyBatis-Plus的全局设置、插件和类型处理器：

**YAML配置：**

```yaml
# MyBatis-Plus配置
mybatis-plus:
  configuration:
    # 开启驼峰命名转换
    map-underscore-to-camel-case: true
    # 二级缓存设置（生产环境可开启，开发环境建议关闭）
    cache-enabled: false
    # 设置当字段为null时调用setter方法
    call-setters-on-nulls: true
    # 设置JDBC类型为null时的默认值
    jdbc-type-for-null: 'null'
    # 日志实现（可选）
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl

  global-config:
    db-config:
      # 主键类型（AUTO为数据库自增，ASSIGN_ID为雪花算法）
      id-type: auto
      # 逻辑删除字段
      logic-delete-field: deleted
      logic-delete-value: 1
      logic-not-delete-value: 0
      # 表名前缀（可选）
      # table-prefix: t_
  
  # Mapper XML文件位置
  mapper-locations: classpath*:/mapper/**/*.xml
  # 类型别名包路径（可选）
  # type-aliases-package: com.example.app.infrastructure.persistence.entity
```

实际项目中的配置示例（来自ddd-demo项目）：

```yaml
# MyBatis Plus配置
mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true
    cache-enabled: false
    call-setters-on-nulls: true
    jdbc-type-for-null: 'null'
  global-config:
    db-config:
      id-type: auto
      logic-delete-field: deleted
      logic-delete-value: 1
      logic-not-delete-value: 0
  mapper-locations: classpath*:/mapper/**/*.xml
```

**Java配置类：**

```java
package com.example.infrastructure.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.BlockAttackInnerInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.transaction.annotation.EnableTransactionManagement;

/**
 * MyBatis Plus 配置类
 * <p>
 * 提供MyBatis-Plus的插件配置，包括分页、乐观锁、防全表更新与删除等功能
 */
@Configuration
@EnableTransactionManagement
@Slf4j
public class MyBatisPlusConfig {

    /**
     * 配置MybatisPlusInterceptor插件
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        
        // 分页插件
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        
        // 乐观锁插件
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        
        // 防止全表更新与删除插件
        interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor());
        
        log.info("MyBatis Plus插件配置完成");
        return interceptor;
    }

    /**
     * 配置SQL性能分析插件（仅在开发和测试环境启用）
     */
    @Bean
    @Profile({"dev", "test"})
    public SqlPerformanceInterceptor sqlPerformanceInterceptor() {
        SqlPerformanceInterceptor interceptor = new SqlPerformanceInterceptor();
        interceptor.setMaxTime(1000); // 超过1秒记录警告
        log.info("SQL性能分析插件配置完成");
        return interceptor;
    }
}
```

在实际项目中，通常在启动类上使用`@MapperScan`注解指定Mapper接口的包路径：

```java
@SpringBootApplication
@MapperScan("com.example.ddddemo.user.infrastructure.persistence.mapper")
public class DddDemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DddDemoApplication.class, args);
    }
}
```
```

### 6.2.4 自定义元数据处理器和SQL性能分析拦截器

**自定义元数据处理器（CustomMetaObjectHandler）：**

```java
package com.example.infrastructure.config;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

/**
 * 自定义元数据处理器
 * <p>
 * 用于自动填充实体类中的创建时间、更新时间等字段，减少重复代码
 * 需要在实体类的字段上添加@TableField注解，并设置fill属性
 * 例如：@TableField(fill = FieldFill.INSERT) 或 @TableField(fill = FieldFill.INSERT_UPDATE)
 */
@Slf4j
@Component
public class CustomMetaObjectHandler implements MetaObjectHandler {

    @Override
    public void insertFill(MetaObject metaObject) {
        log.debug("开始执行插入填充");
        
        // 判断属性是否存在，存在则自动填充
        if (metaObject.hasSetter("createTime")) {
            this.strictInsertFill(metaObject, "createTime", LocalDateTime.class, LocalDateTime.now());
        }
        
        if (metaObject.hasSetter("updateTime")) {
            this.strictInsertFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
        }
        
        // 创建人（如果有需要）
        if (metaObject.hasSetter("createBy")) {
            String currentUsername = getCurrentUsername();
            this.strictInsertFill(metaObject, "createBy", String.class, currentUsername);
        }
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        log.debug("开始执行更新填充");
        
        // 更新时间
        if (metaObject.hasSetter("updateTime")) {
            this.strictUpdateFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
        }
        
        // 更新人（如果有需要）
        if (metaObject.hasSetter("updateBy")) {
            String currentUsername = getCurrentUsername();
            this.strictUpdateFill(metaObject, "updateBy", String.class, currentUsername);
        }
    }
    
    /**
     * 获取当前用户名
     * <p>
     * 根据实际项目的认证方式获取当前用户信息
     */
    private String getCurrentUsername() {
        try {
            // 这里根据实际项目的认证方式获取当前用户信息
            // 例如：从Spring Security上下文、JWT Token、请求头等获取
            
            // 示例：从Spring Security上下文获取
            // Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            // if (authentication != null && authentication.isAuthenticated()) {
            //     return authentication.getName();
            // }
            
            // 示例：从请求上下文获取
            // String username = RequestContextHolder.getRequestAttributes() != null ?
            //     ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest().getHeader("X-User-Name") : null;
            // if (username != null && !username.isEmpty()) {
            //     return username;
            // }
            
            // 默认用户名
            return "system";
        } catch (Exception e) {
            log.warn("获取当前用户名失败", e);
            return "system";
        }
    }
}
```

在实体类中的使用示例：

```java
@Data
@TableName("t_user")
public class UserDO {
    // 其他字段...
    
    /** 创建时间 */
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;

    /** 更新时间 */
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
}
```
```

**SQL性能分析拦截器：**

在MyBatis-Plus 3.4.0及以上版本中，推荐使用`InnerInterceptor`接口实现SQL性能分析。以下是一个更完善的SQL性能分析拦截器实现：

```java
package com.example.infrastructure.config;

import com.baomidou.mybatisplus.extension.plugins.inner.InnerInterceptor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.executor.statement.StatementHandler;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ParameterMapping;
import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.type.TypeHandlerRegistry;

import java.sql.Connection;
import java.text.DateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.regex.Matcher;

/**
 * SQL性能分析拦截器
 * <p>
 * 用于分析SQL执行性能，记录慢SQL，便于优化
 */
@Slf4j
@Data
public class SqlPerformanceInterceptor implements InnerInterceptor {

    /** 最大执行时间，单位毫秒 */
    private long maxTime = 1000; // 默认超过1秒的SQL会被记录为慢SQL
    
    /** 是否格式化SQL */
    private boolean format = false;
    
    /** 是否输出实际参数值 */
    private boolean showParams = true;
    
    /** 是否记录所有SQL，false则只记录慢SQL */
    private boolean logAllSql = false;
    
    /** 是否写入慢SQL日志文件 */
    private boolean writeIntoFile = false;
    
    /** 慢SQL日志文件路径 */
    private String slowSqlLogFilePath = "logs/slow-sql.log";

    @Override
    public void beforePrepare(StatementHandler sh, Connection connection, Integer transactionTimeout) {
        MetaObject metaObject = MetaObject.forObject(sh);
        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue("delegate.mappedStatement");
        String sqlId = mappedStatement.getId();
        BoundSql boundSql = sh.getBoundSql();
        String sql = boundSql.getSql();
        Object parameterObject = boundSql.getParameterObject();
        List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();

        // 格式化SQL
        String formattedSql = sql;
        if (showParams) {
            formattedSql = formatSql(mappedStatement.getConfiguration(), sql, parameterObject, parameterMappings);
        }
        
        if (format) {
            formattedSql = beautifySql(formattedSql);
        }

        long start = System.currentTimeMillis();
        try {
            // 执行SQL
            InnerInterceptor.super.beforePrepare(sh, connection, transactionTimeout);
        } finally {
            long end = System.currentTimeMillis();
            long timing = end - start;
            
            // 记录慢SQL
            if (timing > maxTime) {
                String slowSqlMessage = String.format("慢SQL检测 - 执行耗时: %d ms, SQL ID: %s, SQL: %s", timing, sqlId, formattedSql);
                log.warn(slowSqlMessage);
                
                // 写入慢SQL日志文件
                if (writeIntoFile) {
                    writeSlowSqlLog(slowSqlMessage);
                }
            } else if (logAllSql) {
                // 记录所有SQL
                log.debug("SQL执行 - 耗时: {} ms, SQL ID: {}, SQL: {}", timing, sqlId, formattedSql);
            }
        }
    }

    /**
     * 写入慢SQL日志到文件
     */
    private void writeSlowSqlLog(String slowSqlMessage) {
        // 实现写入日志文件的逻辑
        // 可以使用java.nio.file.Files或者其他日志框架实现
        try {
            java.nio.file.Files.write(
                java.nio.file.Paths.get(slowSqlLogFilePath),
                (java.time.LocalDateTime.now() + " - " + slowSqlMessage + "\n").getBytes(),
                java.nio.file.StandardOpenOption.CREATE,
                java.nio.file.StandardOpenOption.APPEND
            );
        } catch (Exception e) {
            log.error("写入慢SQL日志文件失败", e);
        }
    }
    
    /**
     * 美化SQL
     */
    private String beautifySql(String sql) {
        // 简单的SQL美化，实际项目中可以使用更复杂的SQL格式化工具
        sql = sql.replaceAll("(?i)SELECT", "\nSELECT")
                .replaceAll("(?i)FROM", "\nFROM")
                .replaceAll("(?i)WHERE", "\nWHERE")
                .replaceAll("(?i)AND", "\n  AND")
                .replaceAll("(?i)OR", "\n   OR")
                .replaceAll("(?i)GROUP BY", "\nGROUP BY")
                .replaceAll("(?i)HAVING", "\nHAVING")
                .replaceAll("(?i)ORDER BY", "\nORDER BY")
                .replaceAll("(?i)LIMIT", "\nLIMIT")
                .replaceAll("(?i)OFFSET", "\nOFFSET")
                .replaceAll("(?i)UPDATE", "\nUPDATE")
                .replaceAll("(?i)DELETE", "\nDELETE")
                .replaceAll("(?i)INSERT", "\nINSERT")
                .replaceAll("(?i)VALUES", "\nVALUES");
        return sql;
    }

    /**
     * 格式化SQL，将占位符替换为实际参数值
     */
    private String formatSql(Configuration configuration, String sql, Object parameterObject, List<ParameterMapping> parameterMappings) {
        if (sql == null || sql.length() == 0 || parameterObject == null) {
            return sql;
        }
        
        // 替换换行符
        sql = sql.replaceAll("[\\s\\n ]+", " ");
        
        if (parameterMappings == null || parameterMappings.isEmpty()) {
            return sql;
        }
        
        TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry();
        
        try {
            // 替换参数
            for (ParameterMapping parameterMapping : parameterMappings) {
                if (parameterMapping.getMode() != ParameterMapping.Mode.IN) {
                    continue;
                }
                
                String propertyName = parameterMapping.getProperty();
                Object value;
                
                if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
                    value = parameterObject;
                } else if (parameterObject instanceof java.util.Map) {
                    value = ((java.util.Map<?, ?>) parameterObject).get(propertyName);
                } else {
                    MetaObject metaObject = configuration.newMetaObject(parameterObject);
                    if (metaObject.hasGetter(propertyName)) {
                        value = metaObject.getValue(propertyName);
                    } else {
                        continue; // 找不到属性，跳过
                    }
                }
                
                String paramValue = formatParameterValue(value);
                sql = sql.replaceFirst("\\?", Matcher.quoteReplacement(paramValue));
            }
        } catch (Exception e) {
            // 参数替换失败，返回原始SQL
            log.debug("SQL参数替换失败", e);
            return sql;
        }
        
        return sql;
    }
    
    /**
     * 格式化参数值
     */
    private String formatParameterValue(Object value) {
        if (value == null) {
            return "null";
        }
        
        if (value instanceof String) {
            return "'" + value.toString().replaceAll("'", "''" ) + "'";
        }
        
        if (value instanceof Date) {
            DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.CHINA);
            return "'" + dateFormat.format(value) + "'";
        }
        
        if (value instanceof java.time.temporal.Temporal) {
            return "'" + value + "'";
        }
        
        return String.valueOf(value);
    }
}
```

在MyBatisPlusConfig中配置此拦截器：

```java
@Bean
public MybatisPlusInterceptor mybatisPlusInterceptor() {
    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
    
    // 添加SQL性能分析拦截器
    SqlPerformanceInterceptor sqlPerformanceInterceptor = new SqlPerformanceInterceptor();
    sqlPerformanceInterceptor.setMaxTime(1000); // 设置SQL最大执行时间
    sqlPerformanceInterceptor.setFormat(true);  // 格式化SQL输出
    
    // 根据环境配置不同的参数
    String activeProfile = env.getActiveProfiles().length > 0 ? env.getActiveProfiles()[0] : "dev";
    if ("dev".equals(activeProfile) || "test".equals(activeProfile)) {
        // 开发环境记录所有SQL
        sqlPerformanceInterceptor.setLogAllSql(true);
    } else {
        // 生产环境只记录慢SQL，并写入日志文件
        sqlPerformanceInterceptor.setLogAllSql(false);
        sqlPerformanceInterceptor.setWriteIntoFile(true);
    }
    
    interceptor.addInnerInterceptor(sqlPerformanceInterceptor);
    
    // 添加其他拦截器...
    
    return interceptor;
}
```

**注意：** 在生产环境中，建议只记录慢SQL，并考虑将慢SQL写入专门的日志文件，便于分析和优化。同时，可以根据实际情况调整慢SQL的阈值，例如在高并发系统中，可能需要将阈值设置得更高一些。
```

**动态表名拦截器：**

在MyBatis-Plus 3.4.0及以上版本中，推荐使用`DynamicTableNameInnerInterceptor`实现动态表名替换功能，用于多租户或分表场景。以下是一个更完善的实现：

```java
@Slf4j
public class DynamicTableNameFactory {
    public static final String TENANT_ID = "ROOR";

    public static TableNameHandler tableNameHandler() {
        return new TableNameHandler() {
            @Override
            public String dynamicTableName(String sql, String tableName) {
                log.debug("动态表名替换: {} -> {}", tableName, tableName + "_" + TENANT_ID);
                if (tableName.equals("t_user")) {
                    return tableName + "_" + TENANT_ID;
                }

                if (tableName.equals("t_log")) {
                    String yearMonth = java.time.LocalDate.now().format(java.time.format.DateTimeFormatter.ofPattern("yyyyMM"));
                    log.debug("动态表名替换: {} -> {}", tableName, tableName + "_" + yearMonth);
                    return tableName + "_" + yearMonth;
                }

                return tableName;
            }
        };
    }
}
```

在MyBatisPlusConfig中配置动态表名拦截器：

```java
@Bean
public MybatisPlusInterceptor mybatisPlusInterceptor() {
   MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
   // 动态表名插件
   DynamicTableNameInnerInterceptor dynamicTableNameInnerInterceptor = new DynamicTableNameInnerInterceptor();
   dynamicTableNameInnerInterceptor.setTableNameHandler(DynamicTableNameFactory.tableNameHandler());
   
   // 分页插件
   interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
   // 乐观锁插件
   interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
   // 防止全表更新与删除插件
   interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor());

   log.info("MyBatis Plus插件配置完成");
   return interceptor;
}
```

**使用动态表名的注意事项：**

1. **性能影响**：动态表名会对SQL解析造成一定的性能影响，建议只在必要的场景下使用。

2. **数据库表准备**：使用动态表名前，需要确保相应的物理表已经创建好，否则会导致SQL执行失败。

3. **表结构一致性**：所有动态生成的表结构应当保持一致，以避免SQL执行时出现字段不匹配的问题。

4. **与分页插件的顺序**：如果同时使用了分页插件，动态表名拦截器应当在分页插件之前添加，即：

```java
interceptor.addInnerInterceptor(dynamicTableNameInnerInterceptor); // 先添加动态表名拦截器
interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); // 再添加分页插件
```

5. **自动建表**：在某些场景下，可能需要实现自动建表功能，可以结合Spring事件监听机制，在应用启动时或首次访问时检查并创建相应的表。
```

## 6.3 仓储实现

### 6.3.1 仓储实现概述

仓储实现是基础设施层的核心组件，负责实现领域层定义的仓储接口，提供数据持久化和查询能力。仓储实现通常包括以下组件：

1. **仓储实现类**：实现领域层定义的仓储接口
2. **Mapper接口**：继承MyBatis-Plus的BaseMapper接口，提供基本的CRUD操作
3. **数据对象（DO）**：映射数据库表结构的对象，使用MyBatis-Plus注解
4. **对象转换器**：在领域对象和数据对象之间进行转换

### 6.3.2 用户仓储实现

以用户仓储为例，展示仓储实现的设计：

```java
/**
 * 用户仓储实现
 * <p>
 * 实现领域层定义的用户仓储接口，提供用户数据的持久化和查询能力。
 * 使用MyBatis Plus作为ORM框架，通过UserMapper访问数据库。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Repository
public class UserRepositoryImpl implements UserRepository {
    
    private final UserMapper userMapper;
    private final UserConverter userConverter;
    
    public UserRepositoryImpl(UserMapper userMapper, UserConverter userConverter) {
        this.userMapper = userMapper;
        this.userConverter = userConverter;
    }
    
    @Override
    public void save(User user) {
        // 将领域对象转换为数据对象
        UserDO userDO = userConverter.toDataObject(user);
        
        // 判断是新增还是更新
        if (userDO.getId() == null) {
            // 新增用户
            userMapper.insert(userDO);
        } else {
            // 更新用户
            userMapper.updateById(userDO);
        }
        
        // 更新领域对象的ID（如果是新增）
        if (user.getId() == null) {
            user.setId(userDO.getId());
        }
    }
    
    @Override
    public User findById(String id) {
        // 查询数据库
        UserDO userDO = userMapper.selectById(id);
        
        // 数据对象转换为领域对象
        return userConverter.toDomainObject(userDO);
    }
    
    @Override
    public List<User> findByQuery(UserQuery query) {
        // 构建查询条件
        LambdaQueryWrapper<UserDO> queryWrapper = new LambdaQueryWrapper<>();
        
        // 添加查询条件
        if (StringUtils.isNotBlank(query.getUsername())) {
            queryWrapper.like(UserDO::getUsername, query.getUsername());
        }
        
        if (StringUtils.isNotBlank(query.getEmail())) {
            queryWrapper.like(UserDO::getEmail, query.getEmail());
        }
        
        if (query.getStatus() != null) {
            queryWrapper.eq(UserDO::getStatus, query.getStatus().name());
        }
        
        // 添加排序
        if (StringUtils.isNotBlank(query.getSort())) {
            // 解析排序字段和方向
            String[] sortParts = query.getSort().split(",");
            String field = sortParts[0];
            boolean isAsc = sortParts.length == 1 || "asc".equalsIgnoreCase(sortParts[1]);
            
            // 添加排序条件
            if ("username".equals(field)) {
                queryWrapper.orderBy(true, isAsc, UserDO::getUsername);
            } else if ("email".equals(field)) {
                queryWrapper.orderBy(true, isAsc, UserDO::getEmail);
            } else if ("createdTime".equals(field)) {
                queryWrapper.orderBy(true, isAsc, UserDO::getCreatedTime);
            }
        }
        
        // 添加分页
        Page<UserDO> page = new Page<>(query.getPage(), query.getSize());
        
        // 执行查询
        Page<UserDO> resultPage = userMapper.selectPage(page, queryWrapper);
        
        // 转换结果
        return resultPage.getRecords().stream()
            .map(userConverter::toDomainObject)
            .collect(Collectors.toList());
    }
    
    @Override
    public void delete(String id) {
        userMapper.deleteById(id);
    }
    
    @Override
    public boolean existsByUsername(String username) {
        LambdaQueryWrapper<UserDO> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(UserDO::getUsername, username);
        return userMapper.selectCount(queryWrapper) > 0;
    }
    
    @Override
    public boolean existsByEmail(String email) {
        LambdaQueryWrapper<UserDO> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(UserDO::getEmail, email);
        return userMapper.selectCount(queryWrapper) > 0;
    }
}
```

### 6.3.3 数据对象设计

数据对象（DO）是映射数据库表结构的对象，通常使用ORM框架的注解进行映射：

```java
/**
 * 用户数据对象
 * <p>
 * 映射用户表结构，使用MyBatis Plus注解进行映射。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Data
@TableName("users")
public class UserDO {
    
    /** 用户ID */
    @TableId(type = IdType.ASSIGN_UUID)
    private String id;
    
    /** 用户名 */
    @TableField("username")
    private String username;
    
    /** 邮箱 */
    @TableField("email")
    private String email;
    
    /** 密码 */
    @TableField("password")
    private String password;
    
    /** 用户状态 */
    @TableField("status")
    private String status;
    
    /** 最后登录时间 */
    @TableField("last_login_time")
    private LocalDateTime lastLoginTime;
    
    /** 创建时间 */
    @TableField("created_time")
    private LocalDateTime createdTime;
    
    /** 更新时间 */
    @TableField("updated_time")
    private LocalDateTime updatedTime;
}
```

### 6.3.4 对象转换器

对象转换器负责在领域对象和数据对象之间进行转换：

```java
/**
 * 用户对象转换器
 * <p>
 * 负责在用户领域对象和用户数据对象之间进行转换。
 * 使用MapStruct自动生成转换代码，提高开发效率。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Mapper(componentModel = "spring")
public interface UserConverter {
    
    /**
     * 将用户领域对象转换为用户数据对象
     *
     * @param user 用户领域对象
     * @return 用户数据对象
     */
    @Mapping(target = "status", expression = "java(user.getStatus().name())")
    UserDO toDataObject(User user);
    
    /**
     * 将用户数据对象转换为用户领域对象
     *
     * @param userDO 用户数据对象
     * @return 用户领域对象
     */
    @Mapping(target = "status", expression = "java(UserStatus.valueOf(userDO.getStatus()))")
    User toDomainObject(UserDO userDO);
}
```

### 6.3.5 数据访问对象

数据访问对象（DAO）封装数据库访问逻辑，通常使用MyBatis Plus的BaseMapper接口：

```java
/**
 * 用户Mapper
 * <p>
 * 继承MyBatis Plus的BaseMapper接口，提供基本的CRUD操作。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Mapper
public interface UserMapper extends BaseMapper<UserDO> {
    
    /**
     * 根据用户名查询用户
     *
     * @param username 用户名
     * @return 用户数据对象
     */
    @Select("SELECT * FROM users WHERE username = #{username}")
    UserDO selectByUsername(String username);
    
    /**
     * 根据邮箱查询用户
     *
     * @param email 邮箱
     * @return 用户数据对象
     */
    @Select("SELECT * FROM users WHERE email = #{email}")
    UserDO selectByEmail(String email);
}
```

## 6.3 缓存实现

### 6.3.1 缓存实现概述

缓存是提高系统性能的关键组件，在基础设施层中实现。缓存实现通常包括以下组件：

1. **缓存配置**：配置缓存管理器、缓存策略和过期策略
2. **缓存服务**：提供缓存操作的接口和实现
3. **缓存切面**：通过AOP实现方法级缓存

### 6.3.2 缓存配置

使用Spring Cache和Redis实现缓存配置：

```java
package com.example.infrastructure.cache;

import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        // 默认缓存配置
        RedisCacheConfiguration defaultCacheConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(30)) // 默认过期时间30分钟
                .serializeKeysWith(
                        RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer())
                )
                .serializeValuesWith(
                        RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer())
                )
                .disableCachingNullValues(); // 不缓存空值

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(defaultCacheConfig)
                .withCacheConfiguration("userCache", // 用户缓存空间
                        defaultCacheConfig.entryTtl(Duration.ofHours(1))) // 1小时过期
                .withCacheConfiguration("productCache", // 产品缓存空间
                        defaultCacheConfig.entryTtl(Duration.ofHours(2))) // 2小时过期
                .transactionAware() // 支持事务
                .build();
    }

    /**
     * 配置Redis模板
     */
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        
        // 设置key序列化器
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        
        // 设置value序列化器
        Jackson2JsonRedisSerializer<Object> jsonSerializer = new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, 
            ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
        jsonSerializer.setObjectMapper(objectMapper);
        
        template.setValueSerializer(jsonSerializer);
        template.setHashValueSerializer(jsonSerializer);
        
        template.afterPropertiesSet();
        return template;
    }

    /**
     * 配置String Redis模板
     */
    @Bean
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory connectionFactory) {
        StringRedisTemplate template = new StringRedisTemplate();
        template.setConnectionFactory(connectionFactory);
        return template;
    }

    /**
     * 配置Redis监听器
     */
    @Bean
    public RedisMessageListenerContainer redisMessageListenerContainer(
            RedisConnectionFactory connectionFactory) {
        
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        
        // 配置监听器
        container.addMessageListener(new CacheEvictionListener(), 
            new ChannelTopic("cache:eviction"));
        
        return container;
    }
}

/**
 * 缓存失效监听器
 */
@Component
@Slf4j
public class CacheEvictionListener implements MessageListener {

    @Override
    public void onMessage(Message message, byte[] pattern) {
        try {
            String channel = new String(message.getChannel());
            String body = new String(message.getBody());
            
            log.info("收到缓存失效消息: channel={}, body={}", channel, body);
            
            // 处理缓存失效逻辑
            handleCacheEviction(body);
            
        } catch (Exception e) {
            log.error("处理缓存失效消息失败", e);
        }
    }

    private void handleCacheEviction(String cacheKey) {
        // 根据缓存key执行相应的失效处理逻辑
        if (cacheKey.startsWith("user:")) {
            // 用户缓存失效处理
            log.info("用户缓存失效: {}", cacheKey);
        } else if (cacheKey.startsWith("order:")) {
            // 订单缓存失效处理
            log.info("订单缓存失效: {}", cacheKey);
        }
    }
}

/**
 * 缓存注解配置
 */
@Configuration
@EnableCaching
public class CacheConfig {

    /**
     * 配置缓存键生成器
     */
    @Bean
    public KeyGenerator keyGenerator() {
        return (target, method, params) -> {
            StringBuilder sb = new StringBuilder();
            sb.append(target.getClass().getSimpleName());
            sb.append(":");
            sb.append(method.getName());
            for (Object param : params) {
                sb.append(":");
                sb.append(param.toString());
            }
            return sb.toString();
        };
    }

    /**
     * 配置缓存解析器
     */
    @Bean
    public CacheResolver cacheResolver(CacheManager cacheManager) {
        return new SimpleCacheResolver(cacheManager);
    }
}
```

### 6.3.3 缓存服务实现

实现通用缓存服务接口：

```java
package com.example.infrastructure.cache;

import java.util.concurrent.TimeUnit;

public interface CacheService {

    /**
     * 设置缓存
     *
     * @param key   缓存键
     * @param value 缓存值
     */
    void set(String key, Object value);

    /**
     * 设置缓存并指定过期时间
     *
     * @param key      缓存键
     * @param value    缓存值
     * @param timeout  过期时间
     * @param timeUnit 时间单位
     */
    void set(String key, Object value, long timeout, TimeUnit timeUnit);

    /**
     * 获取缓存
     *
     * @param key   缓存键
     * @param clazz 返回类型
     * @param <T>   泛型类型
     * @return 缓存值
     */
    <T> T get(String key, Class<T> clazz);

    /**
     * 删除缓存
     *
     * @param key 缓存键
     * @return 是否成功
     */
    boolean delete(String key);

    /**
     * 判断缓存是否存在
     *
     * @param key 缓存键
     * @return 是否存在
     */
    boolean hasKey(String key);

    /**
     * 设置过期时间
     *
     * @param key      缓存键
     * @param timeout  过期时间
     * @param timeUnit 时间单位
     * @return 是否成功
     */
    boolean expire(String key, long timeout, TimeUnit timeUnit);
}
```

缓存服务Redis实现：

```java
package com.example.infrastructure.cache;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

@Service
public class RedisCacheServiceImpl implements CacheService {

    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;

    public RedisCacheServiceImpl(RedisTemplate<String, Object> redisTemplate, ObjectMapper objectMapper) {
        this.redisTemplate = redisTemplate;
        this.objectMapper = objectMapper;
    }

    @Override
    public void set(String key, Object value) {
        redisTemplate.opsForValue().set(key, value);
    }

    @Override
    public void set(String key, Object value, long timeout, TimeUnit timeUnit) {
        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);
    }

    @Override
    public <T> T get(String key, Class<T> clazz) {
        Object value = redisTemplate.opsForValue().get(key);
        if (value == null) {
            return null;
        }
        
        if (value instanceof String) {
            try {
                return objectMapper.readValue((String) value, clazz);
            } catch (Exception e) {
                throw new RuntimeException("Failed to deserialize cache value", e);
            }
        } else if (clazz.isInstance(value)) {
            return clazz.cast(value);
        } else {
            return objectMapper.convertValue(value, clazz);
        }
    }

    @Override
    public boolean delete(String key) {
        return Boolean.TRUE.equals(redisTemplate.delete(key));
    }

    @Override
    public boolean hasKey(String key) {
        return Boolean.TRUE.equals(redisTemplate.hasKey(key));
    }

    @Override
    public boolean expire(String key, long timeout, TimeUnit timeUnit) {
        return Boolean.TRUE.equals(redisTemplate.expire(key, timeout, timeUnit));
    }
}
```

### 6.3.4 缓存切面实现

使用Spring AOP实现方法级缓存切面：

```java
package com.example.infrastructure.cache;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;
import java.util.concurrent.TimeUnit;

@Aspect
@Component
public class CacheAspect {

    private final CacheService cacheService;

    public CacheAspect(CacheService cacheService) {
        this.cacheService = cacheService;
    }

    @Around("@annotation(com.example.infrastructure.cache.Cacheable)")
    public Object cache(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        
        // 获取注解
        Cacheable cacheable = method.getAnnotation(Cacheable.class);
        if (cacheable == null) {
            return joinPoint.proceed();
        }
        
        // 构建缓存键
        String key = buildCacheKey(cacheable.key(), joinPoint);
        Class<?> returnType = method.getReturnType();
        
        // 尝试从缓存获取
        Object cachedValue = cacheService.get(key, returnType);
        if (cachedValue != null) {
            return cachedValue;
        }
        
        // 执行方法
        Object apiResponse = joinPoint.proceed();
        if (apiResponse != null) {
            // 存入缓存
            cacheService.set(key, apiResponse, cacheable.expiration(), TimeUnit.SECONDS);
        }
        
        return apiResponse;
    }
    
    private String buildCacheKey(String keyPattern, ProceedingJoinPoint joinPoint) {
        // 简单实现，实际应用中可能需要解析SpEL表达式
        if (keyPattern.isEmpty()) {
            MethodSignature signature = (MethodSignature) joinPoint.getSignature();
            return signature.getDeclaringTypeName() + "." + signature.getName();
        }
        return keyPattern;
    }
}
```

自定义缓存注解：

```java
package com.example.infrastructure.cache;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Cacheable {

    /**
     * 缓存键，支持SpEL表达式
     */
    String key() default "";

    /**
     * 过期时间（秒）
     */
    long expiration() default 1800; // 默认30分钟
}
```

## 6.4 安全实现

### 6.4.1 安全实现概述

安全实现是基础设施层的重要组成部分，负责实现系统的认证、授权和安全控制。在本项目中，我们使用Spring Security作为安全框架，实现基于JWT的认证机制。

安全实现通常包括以下组件：

1. **安全配置**：配置Spring Security的安全规则和策略
2. **认证提供者**：实现用户认证逻辑
3. **JWT令牌提供者**：生成和验证JWT令牌
4. **安全过滤器**：拦截请求，进行安全检查

### 6.4.2 安全配置

```java
/**
 * 安全配置
 * <p>
 * 配置Spring Security的安全规则和策略。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    private final JwtTokenProvider jwtTokenProvider;
    
    public SecurityConfig(JwtTokenProvider jwtTokenProvider) {
        this.jwtTokenProvider = jwtTokenProvider;
    }
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // 禁用CSRF，因为我们使用JWT进行认证
        http.csrf(csrf -> csrf.disable())
            // 配置异常处理
            .exceptionHandling(exceptionHandling -> exceptionHandling
                .authenticationEntryPoint((request, response, authException) -> {
                    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
                    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                    response.getWriter().write("{\"
                        + "error\":\"未授权\",\"message\":\"" + authException.getMessage() + "\"
                        + "}");
                })
                .accessDeniedHandler((request, response, accessDeniedException) -> {
                    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
                    response.setStatus(HttpServletResponse.SC_FORBIDDEN);
                    response.getWriter().write("{\"
                        + "error\":\"拒绝访问\",\"message\":\"" + accessDeniedException.getMessage() + "\"
                        + "}");
                })
            )
            // 配置会话管理，使用无状态会话
            .sessionManagement(sessionManagement -> sessionManagement
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            // 配置请求授权规则
            .authorizeHttpRequests(authorizeRequests -> authorizeRequests
                // 公开接口，不需要认证
                .requestMatchers("/api/auth/**", "/api/public/**").permitAll()
                // Swagger UI资源
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                // 健康检查接口
                .requestMatchers("/actuator/health").permitAll()
                // 其他所有请求需要认证
                .anyRequest().authenticated()
            )
            // 添加JWT过滤器
            .addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider),
                           UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
}
```

### 6.4.3 JWT认证实现

```java
/**
 * JWT令牌提供者
 * <p>
 * 提供JWT令牌的生成、验证和解析功能。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class JwtTokenProvider {
    
    @Value("${jwt.secret}")
    private String jwtSecret;
    
    @Value("${jwt.expiration}")
    private long jwtExpiration;
    
    private final UserDetailsService userDetailsService;
    
    public JwtTokenProvider(UserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }
    
    /**
     * 生成JWT令牌
     *
     * @param authentication 认证信息
     * @return JWT令牌
     */
    public String generateToken(Authentication authentication) {
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpiration);
        
        return Jwts.builder()
            .subject(userDetails.getUsername())
            .issuedAt(now)
            .expiration(expiryDate)
            .signWith(Keys.hmacShaKeyFor(jwtSecret.getBytes()))
            .compact();
    }
    
    /**
     * 从JWT令牌中获取用户名
     *
     * @param token JWT令牌
     * @return 用户名
     */
    public String getUsernameFromToken(String token) {
        Claims claims = Jwts.parser()
            .verifyWith(Keys.hmacShaKeyFor(jwtSecret.getBytes()))
            .build()
            .parseSignedClaims(token)
            .getPayload();
        
        return claims.getSubject();
    }
    
    /**
     * 验证JWT令牌
     *
     * @param token JWT令牌
     * @return 是否有效
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                .verifyWith(Keys.hmacShaKeyFor(jwtSecret.getBytes()))
                .build()
                .parseSignedClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
    
    /**
     * 从JWT令牌中获取认证信息
     *
     * @param token JWT令牌
     * @return 认证信息
     */
    public Authentication getAuthentication(String token) {
        String username = getUsernameFromToken(token);
        UserDetails userDetails = userDetailsService.loadUserByUsername(username);
        return new UsernamePasswordAuthenticationToken(userDetails, "", userDetails.getAuthorities());
    }
}

/**
 * JWT认证过滤器
 * <p>
 * 拦截请求，验证JWT令牌并设置认证信息。
 * 
 * @author chensoul
 * @since 1.0.0
 */
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    private final JwtTokenProvider jwtTokenProvider;
    
    public JwtAuthenticationFilter(JwtTokenProvider jwtTokenProvider) {
        this.jwtTokenProvider = jwtTokenProvider;
    }
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {
        
        try {
            // 从请求头中获取JWT令牌
            String jwt = getJwtFromRequest(request);
            
            // 验证JWT令牌
            if (StringUtils.hasText(jwt) && jwtTokenProvider.validateToken(jwt)) {
                // 获取认证信息
                Authentication authentication = jwtTokenProvider.getAuthentication(jwt);
                // 设置认证信息
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            logger.error("无法设置用户认证", ex);
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}

/**
 * 用户详情服务实现
 * <p>
 * 实现Spring Security的UserDetailsService接口，提供用户认证信息。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    
    private final UserRepository userRepository;
    
    public UserDetailsServiceImpl(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 查询用户
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("用户不存在: " + username));
        
        // 检查用户状态
        if (user.getStatus() != UserStatus.ACTIVE) {
            throw new DisabledException("用户已停用: " + username);
        }
        
        // 构建UserDetails对象
        return org.springframework.security.core.userdetails.User.builder()
            .username(user.getUsername())
            .password(user.getPassword())
            .authorities("ROLE_USER")
            .build();
    }
}
```

## 6.4 领域事件发布器实现

### 6.4.1 领域事件发布器实现概述

领域事件发布器负责发布领域事件，通常基于Spring的事件机制实现：

```java
/**
 * Spring领域事件发布器
 * <p>
 * 基于Spring的ApplicationEventPublisher实现领域事件的发布。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class SpringDomainEventPublisher implements DomainEventPublisher {
    
    private final ApplicationEventPublisher eventPublisher;
    
    public SpringDomainEventPublisher(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }
    
    @Override
    public void publish(DomainEvent<?, ?> event) {
        eventPublisher.publishEvent(event);
    }
    
    @Override
    public void publishEvents(List<DomainEvent<?, ?>> events) {
        events.forEach(this::publish);
    }
}
```

### 6.4.2 领域事件处理器实现

领域事件处理器负责处理领域事件，通常基于Spring的事件监听机制实现：

```java
/**
 * 用户创建事件处理器
 * <p>
 * 处理用户创建事件，实现领域事件处理器接口。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class UserCreatedEventHandler implements DomainEventHandler<UserCreatedEvent> {
    
    private final EmailService emailService;
    
    public UserCreatedEventHandler(EmailService emailService) {
        this.emailService = emailService;
    }
    
    @Override
    public void handle(UserCreatedEvent event) {
        // 发送欢迎邮件
        emailService.sendWelcomeEmail(event.getEmail(), event.getUsername());
    }
    
    @Override
    public Class<UserCreatedEvent> getSupportedEventType() {
        return UserCreatedEvent.class;
    }
    
    @Override
    public int getOrder() {
        return 0;
    }
}
```

### 6.4.3 Spring事件监听器

使用Spring的事件监听机制，将领域事件处理器与Spring事件系统集成：

```java
/**
 * 领域事件监听器
 * <p>
 * 监听Spring事件系统中的领域事件，并将其分发给对应的领域事件处理器。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Component
public class DomainEventListener {
    
    private final List<DomainEventHandler> eventHandlers;
    
    public DomainEventListener(List<DomainEventHandler> eventHandlers) {
        this.eventHandlers = eventHandlers;
    }
    
    @EventListener
    public void handleDomainEvent(DomainEvent<?, ?> event) {
        // 查找支持该事件类型的处理器
        List<DomainEventHandler> handlers = eventHandlers.stream()
            .filter(handler -> handler.getSupportedEventType().isAssignableFrom(event.getClass()))
            .sorted(Comparator.comparingInt(DomainEventHandler::getOrder))
            .collect(Collectors.toList());
        
        // 调用处理器处理事件
        for (DomainEventHandler handler : handlers) {
            handler.handle(event);
        }
    }
}
## 6.5 日志实现

### 6.5.1 日志实现概述

日志是系统运行过程中记录信息的重要手段，在基础设施层中实现。日志实现通常包括以下组件：

1. **日志配置**：配置日志级别、输出格式和输出目标
2. **日志切面**：通过AOP实现方法级日志记录
3. **日志工具类**：提供便捷的日志记录接口

### 6.5.2 日志配置

使用Logback作为日志实现框架，配置日志：

**application.yml 日志配置：**

```yaml
# 日志配置
logging:
  # 日志级别配置
  level:
    root: INFO
    # 应用包日志级别
    com.example.ddddemo: DEBUG
    # SQL日志 - 开发环境开启
    com.example.ddddemo.infrastructure.persistence.mapper: DEBUG
    # MyBatis Plus日志
    com.baomidou.mybatisplus: DEBUG
    # HikariCP连接池日志
    com.zaxxer.hikari: INFO
    # Spring框架日志
    org.springframework: INFO
    org.springframework.web: DEBUG
    org.springframework.security: DEBUG
    # 第三方库日志
    org.apache.http: INFO
    redis.clients.jedis: INFO

  # 日志输出格式
  pattern:
    # 控制台输出格式
    console: "%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(%5p) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n%wEx"
    # 文件输出格式
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} %5p ${PID:- } --- [%t] %-40.40logger{39} : %m%n"

  # 日志文件配置
  file:
    # 日志文件路径
    name: logs/ddd-demo.log
    # 日志文件最大大小
    max-size: 100MB
    # 日志文件最大历史数量
    max-history: 30
    # 日志文件总大小限制
    total-size-cap: 1GB
```

**不同环境的日志配置：**

```yaml
# application-dev.yml - 开发环境
logging:
  level:
    root: DEBUG
    com.example.ddddemo: DEBUG
    # 开启SQL日志
    com.example.ddddemo.infrastructure.persistence.mapper: DEBUG
    com.baomidou.mybatisplus.core.mapper: DEBUG
  file:
    name: logs/ddd-demo-dev.log

---
# application-test.yml - 测试环境
logging:
  level:
    root: INFO
    com.example.ddddemo: INFO
    # 关闭详细SQL日志
    com.example.ddddemo.infrastructure.persistence.mapper: WARN
  file:
    name: logs/ddd-demo-test.log

---
# application-prod.yml - 生产环境
logging:
  level:
    root: WARN
    com.example.ddddemo: INFO
    # 生产环境关闭SQL日志
    com.example.ddddemo.infrastructure.persistence.mapper: ERROR
  file:
    name: logs/ddd-demo-prod.log
    # 生产环境更严格的日志轮转
    max-size: 50MB
    max-history: 7
```
**Logback配置文件 (logback-spring.xml)：**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 引入Spring Boot默认配置 -->
    <include resource="org/springframework/boot/logging/logback/defaults.xml"/>

    <!-- 定义日志文件路径 -->
    <springProfile name="!prod">
        <property name="LOG_FILE" value="logs/ddd-demo"/>
    </springProfile>
    <springProfile name="prod">
        <property name="LOG_FILE" value="/var/log/ddd-demo/ddd-demo"/>
    </springProfile>

    <!-- 控制台输出 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- 文件输出 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_FILE}.log</file>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_FILE}.%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>
            <maxFileSize>100MB</maxFileSize>
            <maxHistory>30</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
    </appender>

    <!-- 错误日志单独输出 -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_FILE}-error.log</file>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_FILE}-error.%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>
            <maxFileSize>50MB</maxFileSize>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
    </appender>

    <!-- 异步日志 -->
    <appender name="ASYNC_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE"/>
        <queueSize>1024</queueSize>
        <discardingThreshold>0</discardingThreshold>
        <includeCallerData>true</includeCallerData>
    </appender>

    <!-- 根日志配置 -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="ASYNC_FILE"/>
        <appender-ref ref="ERROR_FILE"/>
    </root>

    <!-- 应用日志配置 -->
    <logger name="com.example.ddddemo" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="ASYNC_FILE"/>
        <appender-ref ref="ERROR_FILE"/>
    </logger>

    <!-- SQL日志配置 -->
    <springProfile name="dev,test">
        <logger name="com.example.ddddemo.infrastructure.persistence.mapper" level="DEBUG"/>
    </springProfile>

    <!-- 生产环境关闭SQL日志 -->
    <springProfile name="prod">
        <logger name="com.example.ddddemo.infrastructure.persistence.mapper" level="ERROR"/>
    </springProfile>
</configuration>
```

### 6.5.3 日志切面实现

使用Spring AOP实现方法级日志记录：

```java
package com.example.infrastructure.logging;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;
import java.util.Arrays;

@Aspect
@Component
public class LoggingAspect {

    @Around("@annotation(com.example.infrastructure.logging.LogExecutionTime) || @within(com.example.infrastructure.logging.LogExecutionTime)")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        Logger logger = LoggerFactory.getLogger(method.getDeclaringClass());
        
        String className = method.getDeclaringClass().getSimpleName();
        String methodName = method.getName();
        
        logger.debug("开始执行 {}.{} 方法，参数: {}", className, methodName, Arrays.toString(joinPoint.getArgs()));
        
        long startTime = System.currentTimeMillis();
        Object apiResponse;
        try {
            apiResponse = joinPoint.proceed();
            long endTime = System.currentTimeMillis();
            logger.debug("完成执行 {}.{} 方法，耗时: {}ms", className, methodName, (endTime - startTime));
            return apiResponse;
        } catch (Exception e) {
            logger.error("执行 {}.{} 方法出错: {}", className, methodName, e.getMessage(), e);
            throw e;
        }
    }
}
```

自定义日志注解：

```java
package com.example.infrastructure.logging;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface LogExecutionTime {
}
```

### 6.5.4 日志工具类

提供便捷的日志记录接口：

```java
package com.example.infrastructure.logging;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import java.util.UUID;

public class LogUtils {

    private static final String TRACE_ID = "traceId";

    /**
     * 获取指定类的日志记录器
     *
     * @param clazz 类
     * @return 日志记录器
     */
    public static Logger getLogger(Class<?> clazz) {
        return LoggerFactory.getLogger(clazz);
    }

    /**
     * 设置跟踪ID
     */
    public static void setTraceId() {
        MDC.put(TRACE_ID, UUID.randomUUID().toString().replace("-", ""));
    }

    /**
     * 设置指定的跟踪ID
     *
     * @param traceId 跟踪ID
     */
    public static void setTraceId(String traceId) {
        MDC.put(TRACE_ID, traceId);
    }

    /**
     * 获取当前跟踪ID
     *
     * @return 跟踪ID
     */
    public static String getTraceId() {
        return MDC.get(TRACE_ID);
    }

    /**
     * 清除跟踪ID
     */
    public static void clearTraceId() {
        MDC.remove(TRACE_ID);
    }

    /**
     * 记录业务操作日志
     *
     * @param operation 操作类型
     * @param operator  操作人
     * @param target    操作对象
     * @param apiResponse    操作结果
     * @param detail    操作详情
     */
    public static void logBusinessOperation(String operation, String operator, String target, boolean apiResponse, String detail) {
        Logger businessLogger = LoggerFactory.getLogger("com.example.business");
        String message = String.format("操作类型: %s, 操作人: %s, 操作对象: %s, 操作结果: %s, 详情: %s",
                operation, operator, target, apiResponse ? "成功" : "失败", detail);
        businessLogger.info(message);
    }
}
```

**日志最佳实践：**

1. **日志级别使用规范**
   ```java
   @Slf4j
   @Service
   public class UserApplicationService {

       public UserDTO createUser(CreateUserCommand command) {
           // INFO: 记录重要的业务操作
           log.info("开始创建用户: username={}", command.getUsername());

           try {
               // DEBUG: 记录详细的执行步骤
               log.debug("校验用户数据: {}", command);

               User user = userFactory.create(command);

               // DEBUG: 记录中间状态
               log.debug("用户聚合创建完成: userId={}", user.getId());

               User savedUser = userRepository.save(user);

               // INFO: 记录操作结果
               log.info("用户创建成功: userId={}, username={}",
                       savedUser.getId(), savedUser.getUsername());

               return UserConverter.toDTO(savedUser);

           } catch (Exception e) {
               // ERROR: 记录异常信息
               log.error("创建用户失败: username={}, error={}",
                        command.getUsername(), e.getMessage(), e);
               throw e;
           }
       }
   }
   ```

2. **结构化日志**
   ```java
   // 使用MDC添加上下文信息
   @Component
   public class LoggingFilter implements Filter {

       @Override
       public void doFilter(ServletRequest request, ServletResponse response,
                           FilterChain chain) throws IOException, ServletException {

           HttpServletRequest httpRequest = (HttpServletRequest) request;

           // 添加请求ID到MDC
           String requestId = UUID.randomUUID().toString();
           MDC.put("requestId", requestId);
           MDC.put("userId", getCurrentUserId());

           try {
               chain.doFilter(request, response);
           } finally {
               // 清理MDC
               MDC.clear();
           }
       }
   }
   ```

3. **性能监控日志**
   ```java
   @Aspect
   @Component
   @Slf4j
   public class PerformanceLoggingAspect {

       @Around("@annotation(com.example.ddddemo.shared.annotation.LogExecutionTime)")
       public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
           long startTime = System.currentTimeMillis();

           try {
               Object apiResponse = joinPoint.proceed();
               long executionTime = System.currentTimeMillis() - startTime;

               // WARN: 记录慢操作
               if (executionTime > 1000) {
                   log.warn("慢操作检测: method={}, executionTime={}ms",
                           joinPoint.getSignature().toShortString(), executionTime);
               } else {
                   log.debug("方法执行时间: method={}, executionTime={}ms",
                           joinPoint.getSignature().toShortString(), executionTime);
               }

               return apiResponse;
           } catch (Exception e) {
               long executionTime = System.currentTimeMillis() - startTime;
               log.error("方法执行异常: method={}, executionTime={}ms, error={}",
                        joinPoint.getSignature().toShortString(), executionTime, e.getMessage());
               throw e;
           }
       }
   }
   ```

**日志配置说明：**

- **开发环境**: 详细的DEBUG日志，包含SQL执行日志
- **测试环境**: 适中的INFO日志，关闭详细SQL日志
- **生产环境**: 精简的WARN日志，完全关闭SQL日志
- **异步日志**: 使用AsyncAppender提升性能
- **日志轮转**: 按大小和时间自动轮转，避免磁盘空间耗尽
- **错误日志**: 单独的错误日志文件，便于问题排查


## 6.6 外部服务集成

### 6.6.1 外部服务集成概述

外部服务集成负责与第三方服务和API进行交互，通常包括以下组件：

1. **服务客户端**：封装与外部服务的通信逻辑
2. **服务配置**：配置外部服务的连接参数
3. **服务适配器**：适配外部服务的接口，使其符合系统需求

### 6.6.2 邮件服务实现

以邮件服务为例，展示外部服务集成的设计：

```java
/**
 * 邮件服务实现
 * <p>
 * 基于Spring Mail实现邮件发送服务。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Service
public class EmailServiceImpl implements EmailService {
    
    private final JavaMailSender mailSender;
    private final VelocityEngine velocityEngine;
    private final String fromAddress;
    
    public EmailServiceImpl(JavaMailSender mailSender, 
                          VelocityEngine velocityEngine,
                          @Value("${mail.from}") String fromAddress) {
        this.mailSender = mailSender;
        this.velocityEngine = velocityEngine;
        this.fromAddress = fromAddress;
    }
    
    @Override
    public void sendWelcomeEmail(String to, String username) {
        // 准备模板数据
        Map<String, Object> model = new HashMap<>();
        model.put("username", username);
        model.put("currentYear", Year.now().getValue());
        
        // 渲染邮件内容
        String text = VelocityEngineUtils.mergeTemplateIntoString(
            velocityEngine, "templates/welcome-email.vm", "UTF-8", model);
        
        // 创建邮件消息
        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom(fromAddress);
        message.setTo(to);
        message.setSubject("欢迎加入我们的平台");
        message.setText(text);
        
        // 发送邮件
        mailSender.send(message);
    }
    
    @Override
    public void sendPasswordResetEmail(String to, String resetToken) {
        // 准备模板数据
        Map<String, Object> model = new HashMap<>();
        model.put("resetToken", resetToken);
        model.put("resetUrl", "https://example.com/reset-password?token=" + resetToken);
        model.put("expirationHours", 24);
        
        // 渲染邮件内容
        String text = VelocityEngineUtils.mergeTemplateIntoString(
            velocityEngine, "templates/password-reset-email.vm", "UTF-8", model);
        
        // 创建邮件消息
        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom(fromAddress);
        message.setTo(to);
        message.setSubject("密码重置请求");
        message.setText(text);
        
        // 发送邮件
        mailSender.send(message);
    }
}
```

### 6.6.3 服务配置

外部服务的配置通常使用Spring的配置机制：

```java
/**
 * 邮件服务配置
 * <p>
 * 配置邮件服务所需的组件，如JavaMailSender和VelocityEngine。
 * 
 * @author chensoul
 * @since 1.0.0
 */
@Configuration
public class EmailConfig {
    
    @Bean
    public JavaMailSender javaMailSender(@Value("${mail.host}") String host,
                                        @Value("${mail.port}") int port,
                                        @Value("${mail.username}") String username,
                                        @Value("${mail.password}") String password) {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost(host);
        mailSender.setPort(port);
        mailSender.setUsername(username);
        mailSender.setPassword(password);
        
        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.starttls.enable", "true");
        
        return mailSender;
    }
    
    @Bean
    public VelocityEngine velocityEngine() {
        VelocityEngine velocityEngine = new VelocityEngine();
        velocityEngine.setProperty(RuntimeConstants.RESOURCE_LOADER, "class");
        velocityEngine.setProperty("class.resource.loader.class", ClasspathResourceLoader.class.getName());
        velocityEngine.init();
        return velocityEngine;
    }
}
```

## 6.7 监控和指标实现

### 6.7.1 监控和指标实现概述

监控和指标是系统运行状态观测的重要手段，在基础设施层中实现。监控和指标实现通常包括以下组件：

1. **指标收集**：收集系统运行时的各种指标数据
2. **健康检查**：检查系统各组件的健康状态
3. **监控配置**：配置监控参数和告警规则

### 6.7.2 指标收集实现

使用Micrometer和Prometheus实现指标收集：

```java
package com.example.infrastructure.monitoring;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import org.springframework.stereotype.Component;

import java.util.concurrent.TimeUnit;

@Component
public class MetricsService {

    private final MeterRegistry meterRegistry;

    public MetricsService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }

    /**
     * 记录请求计数
     *
     * @param endpoint 接口路径
     * @param method   HTTP方法
     */
    public void recordRequest(String endpoint, String method) {
        Counter.builder("http.requests")
                .tag("endpoint", endpoint)
                .tag("method", method)
                .register(meterRegistry)
                .increment();
    }

    /**
     * 记录请求耗时
     *
     * @param endpoint 接口路径
     * @param method   HTTP方法
     * @param timeMs   耗时（毫秒）
     */
    public void recordRequestTime(String endpoint, String method, long timeMs) {
        Timer.builder("http.request.duration")
                .tag("endpoint", endpoint)
                .tag("method", method)
                .register(meterRegistry)
                .record(timeMs, TimeUnit.MILLISECONDS);
    }

    /**
     * 记录业务操作计数
     *
     * @param operation 操作类型
     * @param apiResponse    操作结果
     */
    public void recordOperation(String operation, boolean apiResponse) {
        Counter.builder("business.operations")
                .tag("operation", operation)
                .tag("apiResponse", apiResponse ? "success" : "failure")
                .register(meterRegistry)
                .increment();
    }

    /**
     * 记录业务操作耗时
     *
     * @param operation 操作类型
     * @param timeMs    耗时（毫秒）
     */
    public void recordOperationTime(String operation, long timeMs) {
        Timer.builder("business.operation.duration")
                .tag("operation", operation)
                .register(meterRegistry)
                .record(timeMs, TimeUnit.MILLISECONDS);
    }

    /**
     * 记录缓存命中率
     *
     * @param cacheName 缓存名称
     * @param hit        是否命中
     */
    public void recordCacheHit(String cacheName, boolean hit) {
        Counter.builder("cache.access")
                .tag("cache", cacheName)
                .tag("apiResponse", hit ? "hit" : "miss")
                .register(meterRegistry)
                .increment();
    }

    /**
     * 记录数据库操作计数
     *
     * @param operation 操作类型
     * @param table     表名
     */
    public void recordDatabaseOperation(String operation, String table) {
        Counter.builder("database.operations")
                .tag("operation", operation)
                .tag("table", table)
                .register(meterRegistry)
                .increment();
    }

    /**
     * 记录数据库操作耗时
     *
     * @param operation 操作类型
     * @param table     表名
     * @param timeMs    耗时（毫秒）
     */
    public void recordDatabaseOperationTime(String operation, String table, long timeMs) {
        Timer.builder("database.operation.duration")
                .tag("operation", operation)
                .tag("table", table)
                .register(meterRegistry)
                .record(timeMs, TimeUnit.MILLISECONDS);
    }
}
```


```java
/**
 * 监控切面
 */
@Aspect
@Component
@Slf4j
public class MonitoringAspect {

    private final MeterRegistry meterRegistry;

    public MonitoringAspect(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }

    /**
     * 监控应用服务方法
     */
    @Around("execution(* com.example.ddddemo.application.service.*.*(..))")
    public Object monitorApplicationService(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();

        Timer.Sample sample = Timer.start(meterRegistry);

        try {
            Object apiResponse = joinPoint.proceed();

            // 记录成功调用
            sample.stop(Timer.builder("application.service.duration")
                .tag("class", className)
                .tag("method", methodName)
                .tag("status", "success")
                .register(meterRegistry));

            return apiResponse;

        } catch (Exception e) {
            // 记录失败调用
            sample.stop(Timer.builder("application.service.duration")
                .tag("class", className)
                .tag("method", methodName)
                .tag("status", "error")
                .register(meterRegistry));

            // 记录异常计数
            Counter.builder("application.service.errors")
                .tag("class", className)
                .tag("method", methodName)
                .tag("exception", e.getClass().getSimpleName())
                .register(meterRegistry)
                .increment();

            throw e;
        }
    }
}
```

**自定义业务指标：**

```java
/**
 * 业务指标配置
 */
@Component
@Slf4j
public class BusinessMetrics {

    private final MeterRegistry meterRegistry;
    private final Counter userCreatedCounter;
    private final Timer userOperationTimer;
    private final Gauge activeUserGauge;

    public BusinessMetrics(MeterRegistry meterRegistry, UserRepository userRepository) {
        this.meterRegistry = meterRegistry;

        // 用户创建计数器
        this.userCreatedCounter = Counter.builder("user.created.total")
            .description("用户创建总数")
            .tag("application", "ddd-demo")
            .register(meterRegistry);

        // 用户操作耗时
        this.userOperationTimer = Timer.builder("user.operation.duration")
            .description("用户操作耗时")
            .tag("application", "ddd-demo")
            .register(meterRegistry);

        // 活跃用户数量
        this.activeUserGauge = Gauge.builder("user.active.count")
            .description("活跃用户数量")
            .tag("application", "ddd-demo")
            .register(meterRegistry, userRepository, repo -> {
                try {
                    return repo.countByStatus(UserStatus.ACTIVE);
                } catch (Exception e) {
                    log.error("获取活跃用户数量失败", e);
                    return 0;
                }
            });
    }

    /**
     * 记录用户创建事件
     */
    public void recordUserCreated() {
        userCreatedCounter.increment();
    }

    /**
     * 记录用户操作耗时
     */
    public void recordUserOperation(String operation, Duration duration) {
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("user.operation.duration")
            .tag("operation", operation)
            .register(meterRegistry));
    }
}
```

### 6.7.3 健康检查实现

使用Spring Boot Actuator实现健康检查：

```java
package com.example.infrastructure.monitoring;

import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class DatabaseHealthIndicator implements HealthIndicator {

    private final javax.sql.DataSource dataSource;

    public DatabaseHealthIndicator(javax.sql.DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public Health health() {
        try (java.sql.Connection connection = dataSource.getConnection()) {
            java.sql.Statement statement = connection.createStatement();
            statement.execute("SELECT 1");
            return Health.up().withDetail("database", "Available").build();
        } catch (Exception e) {
            return Health.down().withDetail("database", "Unavailable").withException(e).build();
        }
    }
}
```

```java
package com.example.infrastructure.monitoring;

import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.data.redis.connection.RedisConnection;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.stereotype.Component;

@Component
public class RedisHealthIndicator implements HealthIndicator {

    private final RedisConnectionFactory redisConnectionFactory;

    public RedisHealthIndicator(RedisConnectionFactory redisConnectionFactory) {
        this.redisConnectionFactory = redisConnectionFactory;
    }

    @Override
    public Health health() {
        try (RedisConnection connection = redisConnectionFactory.getConnection()) {
            connection.ping();
            return Health.up().withDetail("redis", "Available").build();
        } catch (Exception e) {
            return Health.down().withDetail("redis", "Unavailable").withException(e).build();
        }
    }
}
```

### 6.7.4 监控配置

配置Actuator和Prometheus：

```java
package com.example.infrastructure.monitoring;

import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.springframework.boot.actuate.autoconfigure.metrics.MeterRegistryCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MonitoringConfig {

    @Bean
    public MeterRegistry meterRegistry() {
        return new SimpleMeterRegistry();
    }

    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config().commonTags("application", "example-app");
    }
}
```

配置Actuator端点：

**Spring Boot Actuator配置 (application.yml)：**

```yaml
# 监控配置
management:
  # 端点配置
  endpoints:
    web:
      # 暴露的端点
      exposure:
        include: health,info,metrics,prometheus,loggers,env,configprops,beans,mappings,hikaricp
      # 端点基础路径
      base-path: /actuator
      # CORS配置
      cors:
        allowed-origins: "*"
        allowed-methods: GET,POST

  # 健康检查配置
  endpoint:
    health:
      # 显示详细健康信息
      show-details: always
      # 显示组件信息
      show-components: always
      # 健康检查缓存时间
      cache:
        time-to-live: 10s

    # 指标端点配置
    metrics:
      enabled: true

    # 日志端点配置
    loggers:
      enabled: true

  # 健康指示器配置
  health:
    # 数据库健康检查
    db:
      enabled: true
    # Redis健康检查
    redis:
      enabled: true
    # 磁盘空间检查
    diskspace:
      enabled: true
      threshold: 100MB

  # 指标配置
  metrics:
    # 启用JVM指标
    enable:
      jvm: true
      system: true
      web: true
      hikaricp: true

    # 指标导出配置
    export:
      # Prometheus指标导出
      prometheus:
        enabled: true
        descriptions: true
        step: 60s

    # 指标标签
    tags:
      application: ddd-demo
      environment: ${spring.profiles.active:dev}
      version: ${app.version:1.0.0}

    # Web指标配置
    web:
      server:
        # 记录请求处理时间
        request:
          autotime:
            enabled: true
            percentiles: 0.5,0.95,0.99
            percentiles-histogram: true

# 应用信息配置
info:
  app:
    name: DDD Demo - 用户管理系统
    description: 基于DDD分层架构的用户管理示例项目
    version: ${app.version:1.0.0}
    encoding: UTF-8
    java:
      version: ${java.version}
  build:
    time: ${build.time:unknown}
    artifact: ${project.artifactId:ddd-demo}
    group: ${project.groupId:com.example}
```

**监控最佳实践：**

1. **关键指标监控**
   ```yaml
   # 推荐监控的关键指标
   metrics:
     - name: jvm.memory.used
       description: JVM内存使用量
       threshold: 80%

     - name: hikaricp.connections.active
       description: 活跃数据库连接数
       threshold: 15

     - name: http.server.requests.duration
       description: HTTP请求响应时间
       threshold: 2s

     - name: user.operation.duration
       description: 用户操作耗时
       threshold: 1s
   ```

2. **告警规则配置 (Prometheus)**
   ```yaml
   # prometheus-alerts.yml
   groups:
     - name: ddd-demo-alerts
       rules:
         # 应用健康检查
         - alert: ApplicationDown
           expr: up{job="ddd-demo"} == 0
           for: 1m
           labels:
             severity: critical
           annotations:
             summary: "DDD Demo应用不可用"
             description: "应用已停止响应超过1分钟"

         # 内存使用率过高
         - alert: HighMemoryUsage
           expr: jvm_memory_used_bytes / jvm_memory_max_bytes > 0.8
           for: 5m
           labels:
             severity: warning
           annotations:
             summary: "内存使用率过高"
             description: "JVM内存使用率超过80%"

         # 响应时间过长
         - alert: HighResponseTime
           expr: http_server_requests_seconds{quantile="0.95"} > 2
           for: 2m
           labels:
             severity: warning
           annotations:
             summary: "响应时间过长"
             description: "95%的请求响应时间超过2秒"

         # 数据库连接池耗尽
         - alert: DatabaseConnectionPoolExhausted
           expr: hikaricp_connections_active / hikaricp_connections_max > 0.9
           for: 1m
           labels:
             severity: critical
           annotations:
             summary: "数据库连接池即将耗尽"
             description: "数据库连接池使用率超过90%"
   ```

3. **监控面板配置 (Grafana)**
   ```json
   {
     "dashboard": {
       "title": "DDD Demo 监控面板",
       "panels": [
         {
           "title": "应用健康状态",
           "type": "stat",
           "targets": [
             {
               "expr": "up{job=\"ddd-demo\"}"
             }
           ]
         },
         {
           "title": "QPS",
           "type": "graph",
           "targets": [
             {
               "expr": "rate(http_server_requests_seconds_count[5m])"
             }
           ]
         },
         {
           "title": "响应时间",
           "type": "graph",
           "targets": [
             {
               "expr": "http_server_requests_seconds{quantile=\"0.95\"}"
             }
           ]
         },
         {
           "title": "JVM内存使用",
           "type": "graph",
           "targets": [
             {
               "expr": "jvm_memory_used_bytes"
             }
           ]
         }
       ]
     }
   }
   ```

**生产环境监控配置：**

```yaml
# application-prod.yml
management:
  endpoints:
    web:
      exposure:
        # 生产环境只暴露必要端点
        include: health,metrics,prometheus
  endpoint:
    health:
      # 生产环境不显示详细信息
      show-details: when-authorized

  # 安全配置
  security:
    enabled: true
    roles: ACTUATOR

# 监控数据保留策略
metrics:
  retention:
    # 指标数据保留7天
    duration: 7d

  # 采样配置
  sampling:
    # 降低采样频率以减少存储压力
    rate: 0.1
```

## 6.8 异步任务处理实现

### 6.8.1 异步任务处理概述

异步任务处理是提高系统性能和可扩展性的重要手段，在基础设施层中实现。异步任务处理通常包括以下组件：

1. **任务调度器**：负责调度和执行异步任务
2. **任务队列**：存储待执行的异步任务
3. **任务执行器**：执行异步任务的线程池

### 6.8.2 异步任务配置

使用Spring的`@Async`和`@Scheduled`注解实现异步任务处理：

```java
package com.example.infrastructure.async;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;

import java.util.concurrent.Executor;

@Configuration
@EnableAsync
@EnableScheduling
public class AsyncConfig {

    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("TaskExecutor-");
        executor.initialize();
        return executor;
    }

    @Bean(name = "emailTaskExecutor")
    public Executor emailTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(50);
        executor.setThreadNamePrefix("EmailExecutor-");
        executor.initialize();
        return executor;
    }

    @Bean
    public ThreadPoolTaskScheduler taskScheduler() {
        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
        scheduler.setPoolSize(5);
        scheduler.setThreadNamePrefix("TaskScheduler-");
        scheduler.setAwaitTerminationSeconds(60);
        scheduler.setWaitForTasksToCompleteOnShutdown(true);
        return scheduler;
    }
}
```

### 6.8.3 异步任务服务实现

```java
package com.example.infrastructure.async;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.concurrent.CompletableFuture;

@Service
public class AsyncTaskService {

    private static final Logger logger = LoggerFactory.getLogger(AsyncTaskService.class);

    /**
     * 异步执行任务
     *
     * @param taskName 任务名称
     * @return CompletableFuture<String> 异步执行结果
     */
    @Async("taskExecutor")
    public CompletableFuture<String> executeTask(String taskName) {
        logger.info("开始执行异步任务: {}, 时间: {}", taskName, LocalDateTime.now());
        try {
            // 模拟耗时操作
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("任务执行被中断: {}", taskName, e);
            return CompletableFuture.completedFuture("任务执行失败: " + taskName);
        }
        logger.info("异步任务执行完成: {}, 时间: {}", taskName, LocalDateTime.now());
        return CompletableFuture.completedFuture("任务执行成功: " + taskName);
    }

    /**
     * 异步发送邮件
     *
     * @param to      收件人
     * @param subject 主题
     * @param content 内容
     * @return CompletableFuture<Boolean> 发送结果
     */
    @Async("emailTaskExecutor")
    public CompletableFuture<Boolean> sendEmailAsync(String to, String subject, String content) {
        logger.info("开始异步发送邮件给: {}, 主题: {}, 时间: {}", to, subject, LocalDateTime.now());
        try {
            // 模拟邮件发送
            Thread.sleep(1000);
            // 实际应用中调用邮件服务发送邮件
            // emailService.sendEmail(to, subject, content);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("邮件发送被中断: {}", subject, e);
            return CompletableFuture.completedFuture(false);
        } catch (Exception e) {
            logger.error("邮件发送失败: {}", subject, e);
            return CompletableFuture.completedFuture(false);
        }
        logger.info("邮件发送完成: {}, 时间: {}", subject, LocalDateTime.now());
        return CompletableFuture.completedFuture(true);
    }

    /**
     * 定时任务：每天凌晨2点执行数据清理
     */
    @Scheduled(cron = "0 0 2 * * ?")
    public void scheduledDataCleanup() {
        logger.info("开始执行定时数据清理任务, 时间: {}", LocalDateTime.now());
        // 实际应用中执行数据清理逻辑
        logger.info("定时数据清理任务完成, 时间: {}", LocalDateTime.now());
    }

    /**
     * 定时任务：每5分钟执行一次健康检查
     */
    @Scheduled(fixedRate = 300000) // 5分钟 = 300000毫秒
    public void scheduledHealthCheck() {
        logger.info("开始执行定时健康检查任务, 时间: {}", LocalDateTime.now());
        // 实际应用中执行健康检查逻辑
        logger.info("定时健康检查任务完成, 时间: {}", LocalDateTime.now());
    }
}
```

### 6.8.4 异步事件处理实现

```java
package com.example.infrastructure.async;

import com.example.domain.event.DomainEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

@Component
public class AsyncEventHandler {

    private static final Logger logger = LoggerFactory.getLogger(AsyncEventHandler.class);

    /**
     * 异步处理领域事件
     *
     * @param event 领域事件
     */
    @Async("taskExecutor")
    @EventListener
    public void handleDomainEventAsync(DomainEvent<?, ?> event) {
        logger.info("异步处理领域事件: {}, 时间: {}", event.getClass().getSimpleName(), event.getOccurredOn());
        // 实际应用中处理领域事件的逻辑
        logger.info("领域事件处理完成: {}", event.getClass().getSimpleName());
    }
}
```
-
## 6.9 总结

本章详细介绍了基础设施层的实现，包括以下关键组件：

1. **数据库访问实现**：使用Spring Data JPA作为ORM框架，配置数据源、实体管理器和事务管理器，使用Flyway进行数据库版本管理。

2. **仓储实现**：实现领域层定义的仓储接口，负责数据持久化和查询，包括数据对象设计、对象转换器和数据访问对象。

3. **缓存实现**：使用Spring Cache和Redis实现缓存服务，提高系统性能，包括缓存配置、缓存服务实现和缓存切面实现。

4. **安全实现**：使用Spring Security和JWT实现认证和授权，保障系统安全，包括安全配置和JWT认证实现。

5. **领域事件发布器实现**：实现领域事件的发布和处理，支持领域层的事件驱动设计，包括事件发布器、事件处理器和事件监听器。

6. **日志实现**：使用Logback实现系统日志记录，包括日志配置、日志切面实现和日志工具类。

7. **外部服务集成**：集成外部系统和服务，如邮件服务，包括服务实现和配置。

8. **监控和指标实现**：使用Spring Boot Actuator和Micrometer实现系统监控和指标收集，包括指标收集、健康检查和监控配置。

9. **异步任务处理实现**：使用Spring的异步任务和调度功能，实现异步任务处理和定时任务，包括任务配置、任务服务和异步事件处理。

基础设施层是整个系统的技术基础，为上层提供必要的技术支持和服务。通过合理设计和实现基础设施层，可以提高系统的性能、可靠性、安全性和可维护性。在实现基础设施层时，应遵循以下原则：

1. **关注点分离**：每个组件只负责特定的技术关注点，避免职责混淆。

2. **依赖倒置**：通过接口和依赖注入实现对领域层的支持，避免领域层依赖基础设施层。

3. **技术封装**：封装技术细节，为上层提供简单清晰的接口，隐藏实现复杂性。

4. **可测试性**：设计易于测试的组件，支持单元测试和集成测试。

5. **可配置性**：提供灵活的配置选项，适应不同的运行环境和需求。

通过遵循这些原则和最佳实践，可以构建一个健壮、灵活、可维护的基础设施层，为整个系统提供坚实的技术基础。
```

