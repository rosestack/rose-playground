---
description: MyBatis Plus 开发规范
alwaysApply: true
---

# MyBatis Plus 开发规范

## 角色定义

作为 MyBatis Plus 开发专家，请严格遵循以下开发规范，确保代码质量、可维护性和数据库兼容性。

## 设计理念

- **数据库无关性**：避免使用数据库特定功能，确保代码可在不同数据库间迁移
- **简洁优雅**：优先使用 MyBatis Plus 提供的 API，减少手写 SQL
- **性能优先**：关注查询性能，合理使用索引和批量操作
- **安全第一**：防止 SQL 注入，使用参数化查询

## Maven 依赖

在父 pom.xml 文件里可以申明 mybatis-plus-bom 依赖管理，mybatis-plus-bom 版本使用 3.5.+，尽量使用最新版本。

```xml

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-bom</artifactId>
            <version>${mybatis-plus.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

在子模块中，如果是 Spring Boot3 项目，则引入 mybatis-plus-spring-boot3-starter 依赖：

```xml
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-spring-boot3-starter</artifactId>
    </dependency>
            
    <!--分页插件-->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-jsqlparser</artifactId>
    </dependency>
```

如果是 Spring Boot2 项目，则引入 mybatis-plus-boot-starter 依赖：

```xml
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
    </dependency>
```

## 配置规范

### MyBatis Plus 配置

```java
@Configuration
@EnableTransactionManagement
public class MybatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();

        // 分页插件
        PaginationInnerInterceptor paginationInterceptor = new PaginationInnerInterceptor(DbType.MYSQL);
        paginationInterceptor.setMaxLimit(1000L); // 最大分页数量限制
        paginationInterceptor.setOverflow(false); // 溢出总页数后是否进行处理
        interceptor.addInnerInterceptor(paginationInterceptor);

        // 乐观锁插件
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());

        // 防全表更新与删除插件
        interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor());

        return interceptor;
    }
}
```

## 实体类规范

### 实体继承体系
```java
// 基础实体类 - 所有实体的父类
public abstract class BaseEntity {
    // 通用字段：createdTime, updatedTime, createdBy, updatedBy, deleted, version
}

// 多租户实体类 - 需要租户隔离的实体
public abstract class BaseTenantEntity extends BaseEntity {
    // 增加租户字段：tenantId
}

// 业务实体类 - 具体的业务实体
public class User extends BaseTenantEntity {
    // 业务字段
}
```

### 实体分类
- **系统级实体**：继承BaseEntity，不包含租户ID，用于系统配置等
- **租户级实体**：继承BaseTenantEntity，包含租户ID，用于业务数据

### BaseEntity 基础实体类

```java
/**
 * 基础实体类
 *
 * @author 开发者姓名
 * @since 版本号
 */
@Data
@EqualsAndHashCode(callSuper = false)
public abstract class BaseEntity implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 创建时间
     */
    @TableField(value = "created_time", fill = FieldFill.INSERT)
    private LocalDateTime createdTime;

    /**
     * 更新时间
     */
    @TableField(value = "updated_time", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedTime;

    /**
     * 创建人
     */
    @TableField(value = "created_by", fill = FieldFill.INSERT)
    private String createdBy;

    /**
     * 更新人
     */
    @TableField(value = "updated_by", fill = FieldFill.INSERT_UPDATE)
    private String updatedBy;

    /**
     * 逻辑删除标识
     */
    @TableLogic
    @TableField(value = "deleted")
    private Boolean deleted;

    /**
     * 乐观锁版本号
     */
    @Version
    @TableField(value = "version")
    private Integer version;
}
```

## Mapper接口规范

### 接口定义

```java
@Mapper
public interface UserMapper extends BaseMapper<User> {
    // 方法定义
}
```

### 继承关系

- **必须继承**：`BaseMapper<T>` 接口
- **必须添加**：`@Mapper` 注解
- **命名规范**：`[实体类名]Mapper`，如 `UserMapper`

### 方法命名规范

- **查询方法**：`selectBy[Field]`、`findBy[Condition]`、`listBy[Condition]`、`page[Entities]`
- **判断方法**：`existsBy[Field]`、`isActive`、`hasPermission`
- **操作方法**：`updateBy[Condition]`、`deleteBy[Field]`
- **统计方法**：`countBy[Condition]`

### 优先级规则

1. **优先使用 Wrapper**：复杂查询使用 LambdaQueryWrapper
2. **简单 SQL 用注解**：单表简单操作使用 @Select、@Update 等
3. **禁用复杂 SQL**：避免多表 JOIN、子查询、数据库特定函数

### Mapper接口可以定义default方法

```java
@Mapper
public interface UserMapper extends BaseMapper<User> {
    /**
     * 根据邮箱查询用户
     */
    @Select("SELECT * FROM user WHERE email = #{email} AND deleted = 0")
    User selectByEmail(@Param("email") String email);

    /**
     * 根据状态查询用户列表
     */
    default List<User> selectByStatus(UserStatus status) {
        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(User::getStatus, status)
                .eq(User::getDeleted, false)
                .orderByDesc(User::getCreatedTime);
        return selectList(wrapper);
    }
}
```

## Service 层规范

### 继承关系

```java
@Slf4j
@Service
@Transactional(rollbackFor = Exception.class)
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {
    // 实现方法
}
```

## Controller 层规范

```java
@GetMapping
public ApiResponse<IPage<UserVO>> pageUsers(Page<User> page, UserQueryRequest request) {
    return ApiResponse.success(userService.pageUsers(request));
}

```

## 性能优化规范

### 查询优化

```java
// ✅ 推荐：使用索引字段查询
wrapper.eq(User::getEmail, email);  // email字段有索引

// ✅ 推荐：避免全表扫描
wrapper.eq(User::getDeleted, false);  // 逻辑删除字段

// ❌ 不推荐：模糊查询开头
wrapper.like(User::getName, "%张三%");  // 无法使用索引

// ✅ 推荐：模糊查询结尾
wrapper.like(User::getName, "张三%");  // 可以使用索引
```

### 批量操作

```java
// ✅ 推荐：批量插入
this.saveBatch(userList, 1000);

// ✅ 推荐：批量更新
this.pdateBatchById(userList, 1000);

// ✅ 推荐：批量删除
this.removeByIds(userIds);
```

## 禁止使用的功能

### 数据库特定功能（严格禁止）

- ❌ **递归查询**：`WITH RECURSIVE`
- ❌ **多表联合查询**：`JOIN` 语句
- ❌ **数据库函数**：`DATE_FORMAT`、`CONCAT` 等
- ❌ **存储过程**：`CALL procedure_name`
- ❌ **触发器依赖**
- ❌ **窗口函数**：`ROW_NUMBER() OVER()`

### 复杂 SQL（避免使用）

- ❌ **复杂动态 SQL**：`<script>` 标签
- ❌ **复杂子查询**
- ❌ **多层嵌套查询**

## 检查清单

在编写 MyBatis Plus 代码时，请确保：

### Mapper 接口检查

- [ ] 继承了 `BaseMapper<T>`
- [ ] 添加了 `@Mapper` 注解
- [ ] 方法命名符合规范
- [ ] 使用了 `@Param` 注解
- [ ] 优先使用 Wrapper 而非手写 SQL
- [ ] 没有使用数据库特定功能

### Service 层检查

- [ ] 继承了 `ServiceImpl<Mapper, Entity>`
- [ ] 添加了事务注解
- [ ] 查询条件构建合理
- [ ] 包含适当的日志记录

### 性能检查

- [ ] 查询使用了索引字段
- [ ] 避免了全表扫描
- [ ] 批量操作使用了批量方法
- [ ] 分页查询设置了合理的限制

### 安全检查

- [ ] 使用了参数化查询
- [ ] 没有 SQL 注入风险
- [ ] 输入参数进行了验证
- [ ] 敏感操作记录了日志
