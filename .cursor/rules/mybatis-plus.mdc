---
description: MyBatis Plus 开发规范
alwaysApply: true
---

# MyBatis Plus 开发规范

## 角色定义

作为 MyBatis Plus 开发专家，请严格遵循以下开发规范，确保代码质量、可维护性和数据库兼容性。

## 设计理念

- **数据库无关性**：避免使用数据库特定功能，确保代码可在不同数据库间迁移
- **简洁优雅**：优先使用 MyBatis Plus 提供的 API，减少手写 SQL
- **性能优先**：关注查询性能，合理使用索引和批量操作
- **安全第一**：防止 SQL 注入，使用参数化查询

## Maven 依赖

在父 pom.xml 文件里可以申明 mybatis-plus-bom 依赖管理，mybatis-plus-bom 版本使用 3.5.+，尽量使用最新版本。

```xml

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-bom</artifactId>
            <version>${mybatis-plus.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

在子模块中，如果是 Spring Boot3 项目，则引入 mybatis-plus-spring-boot3-starter 依赖：

```xml
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-spring-boot3-starter</artifactId>
    </dependency>
            
    <!--分页插件-->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-jsqlparser</artifactId>
    </dependency>
```

如果是 Spring Boot2 项目，则引入 mybatis-plus-boot-starter 依赖：

```xml
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
    </dependency>
```

## 配置规范

### MyBatis Plus 配置

```java
@Configuration
@EnableTransactionManagement
public class MybatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();

        // 分页插件
        PaginationInnerInterceptor paginationInterceptor = new PaginationInnerInterceptor(DbType.MYSQL);
        paginationInterceptor.setMaxLimit(1000L); // 最大分页数量限制
        paginationInterceptor.setOverflow(false); // 溢出总页数后是否进行处理
        interceptor.addInnerInterceptor(paginationInterceptor);

        // 乐观锁插件
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());

        // 防全表更新与删除插件
        interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor());

        return interceptor;
    }
}
```

### 应用配置文件

```yaml
# MyBatis Plus 配置
mybatis-plus:
  configuration:
    # 驼峰命名转换
    map-underscore-to-camel-case: true
    # 关闭二级缓存
    cache-enabled: false
    # 空值处理
    call-setters-on-nulls: true
    jdbc-type-for-null: null
    # 日志实现
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl
  global-config:
    db-config:
      # 主键策略
      id-type: ASSIGN_ID
      # 逻辑删除配置
      logic-delete-field: deleted
      logic-delete-value: 1
      logic-not-delete-value: 0
      # 字段策略
      update-strategy: NOT_NULL
      insert-strategy: NOT_NULL
      select-strategy: NOT_EMPTY
    # 关闭 banner
    banner: false
  # Mapper XML 文件位置
  mapper-locations: classpath*:mapper/**/*.xml
  # 实体类包路径
  type-aliases-package: com.rose.**.entity
  # 类型处理器包路径
  type-handlers-package: com.rose.**.handler
```

## 实体类规范

### 实体继承体系
```java
// 基础实体类 - 所有实体的父类
public abstract class BaseEntity {
    // 通用字段：createdTime, updatedTime, createdBy, updatedBy, deleted, version
}

// 多租户实体类 - 需要租户隔离的实体
public abstract class BaseTenantEntity extends BaseEntity {
    // 增加租户字段：tenantId
}

// 业务实体类 - 具体的业务实体
public class User extends BaseTenantEntity {
    // 业务字段
}
```

### 实体分类
- **系统级实体**：继承BaseEntity，不包含租户ID，用于系统配置等
- **租户级实体**：继承BaseTenantEntity，包含租户ID，用于业务数据

### BaseTenantEntity 多租户实体类

```java
/**
 * 多租户基础实体类
 *
 * @author 开发者姓名
 * @since 版本号
 */
@Data
@EqualsAndHashCode(callSuper = true)
public abstract class BaseTenantEntity extends BaseEntity {

    /**
     * 租户ID
     */
    @TableField(value = "tenant_id")
    private String tenantId;
}
```

### 业务实体类定义示例

```java
@Data
@EqualsAndHashCode(callSuper = true)
@TableName("user")
public class User extends BaseTenantEntity {
    
    @TableId(value = "id", type = IdType.ASSIGN_ID)
    private Long id;
    
    @TableField("username")
    private String username;
    
    @TableField("email")
    private String email;
    
    @TableField("phone")
    private String phone;
    
    @TableField("status")
    @EnumValue
    private UserStatus status;
}
```

### BaseEntity 基础实体类

```java
/**
 * 基础实体类
 *
 * @author 开发者姓名
 * @since 版本号
 */
@Data
@EqualsAndHashCode(callSuper = false)
public abstract class BaseEntity implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 创建时间
     */
    @TableField(value = "created_time", fill = FieldFill.INSERT)
    private LocalDateTime createdTime;

    /**
     * 更新时间
     */
    @TableField(value = "updated_time", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedTime;

    /**
     * 创建人
     */
    @TableField(value = "created_by", fill = FieldFill.INSERT)
    private String createdBy;

    /**
     * 更新人
     */
    @TableField(value = "updated_by", fill = FieldFill.INSERT_UPDATE)
    private String updatedBy;

    /**
     * 逻辑删除标识
     */
    @TableLogic
    @TableField(value = "deleted")
    private Boolean deleted;

    /**
     * 乐观锁版本号
     */
    @Version
    @TableField(value = "version")
    private Integer version;
}
```

## Mapper接口规范

### 接口定义

```java
@Mapper
public interface UserMapper extends BaseMapper<User> {
    // 方法定义
}
```

### 继承关系

- **必须继承**：`BaseMapper<T>` 接口
- **必须添加**：`@Mapper` 注解
- **命名规范**：`[实体类名]Mapper`，如 `UserMapper`

### 方法命名规范

- **查询方法**：`selectBy[Field]`、`findBy[Condition]`、`listBy[Condition]`、`page[Entities]`
- **判断方法**：`existsBy[Field]`、`isActive`、`hasPermission`
- **操作方法**：`updateBy[Condition]`、`deleteBy[Field]`
- **统计方法**：`countBy[Condition]`

### 优先级规则

1. **优先使用 Wrapper**：复杂查询使用 LambdaQueryWrapper
2. **简单 SQL 用注解**：单表简单操作使用 @Select、@Update 等
3. **禁用复杂 SQL**：避免多表 JOIN、子查询、数据库特定函数

### Mapper接口可以定义default方法

```java
@Mapper
public interface UserMapper extends BaseMapper<User> {
    /**
     * 根据邮箱查询用户
     */
    @Select("SELECT * FROM user WHERE email = #{email} AND deleted = 0")
    User selectByEmail(@Param("email") String email);

    /**
     * 根据状态查询用户列表
     */
    default List<User> selectByStatus(UserStatus status) {
        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(User::getStatus, status)
                .eq(User::getDeleted, false)
                .orderByDesc(User::getCreatedTime);
        return selectList(wrapper);
    }
}
```

## Service 层规范

### 继承关系

```java
@Slf4j
@Service
@Transactional(rollbackFor = Exception.class)
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {
    // 实现方法
}
```

### 分页查询规范

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {
    
    private final UserConverter userConverter;
    
    @Override
    @Transactional(readOnly = true)
    public IPage<UserResponse> pageUsers(Page<User> page, UserPageRequest request) {
        // 设置分页限制
        if (page.getSize() > 1000) {
            page.setSize(1000);
        }
        
        // 构建查询条件
        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
        wrapper.like(StringUtils.hasText(request.getUsername()), User::getUsername, request.getUsername())
                .eq(StringUtils.hasText(request.getEmail()), User::getEmail, request.getEmail())
                .eq(request.getStatus() != null, User::getStatus, request.getStatus())
                .eq(User::getDeleted, false)
                .orderByDesc(User::getCreatedTime);
        
        // 执行分页查询
        IPage<User> userPage = page(page, wrapper);
        
        // 转换响应对象
        return userConverter.toPageResponse(userPage);
    }
}
```

## Controller 层规范

### 分页查询调用

```java
// 控制器中的分页调用（使用 MyBatis-Plus 的 Page 对象）
@GetMapping
public ApiResponse<IPage<UserResponse>> pageUsers(Page<User> page, @Valid UserPageRequest request) {
    IPage<UserResponse> response = userService.pageUsers(page, request);
    return ApiResponse.success(response);
}
```

## 对象映射规范

### MapStruct 转换器（分页对象转换）

```java
@Mapper(componentModel = "spring")
public interface UserConverter {
    
    UserResponse toResponse(User user);
    
    User toEntity(UserCreateRequest request);
    
    /**
     * 分页对象转换（使用 MyBatis Plus 分页对象）
     */
    default IPage<UserResponse> toPageResponse(IPage<User> userPage) {
        IPage<UserResponse> responsePage = new Page<>();
        responsePage.setCurrent(userPage.getCurrent());
        responsePage.setSize(userPage.getSize());
        responsePage.setTotal(userPage.getTotal());
        responsePage.setPages(userPage.getPages());
        
        List<UserResponse> records = userPage.getRecords().stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
        responsePage.setRecords(records);
        
        return responsePage;
    }
}
```

## 性能优化规范

### MyBatis Plus 性能配置

```yaml
mybatis-plus:
  configuration:
    # 开启二级缓存
    cache-enabled: true
    # 延迟加载
    lazy-loading-enabled: true
    aggressive-lazy-loading: false
    # 批量操作
    default-executor-type: reuse
  global-config:
    # 性能分析插件（仅开发环境）
    db-config:
      # 批量插入优化
      batch-size: 1000
```

### 查询优化

```java
// ✅ 推荐：使用索引字段查询
wrapper.eq(User::getEmail, email);  // email字段有索引

// ✅ 推荐：避免全表扫描
wrapper.eq(User::getDeleted, false);  // 逻辑删除字段

// ❌ 不推荐：模糊查询开头
wrapper.like(User::getName, "%张三%");  // 无法使用索引

// ✅ 推荐：模糊查询结尾
wrapper.like(User::getName, "张三%");  // 可以使用索引
```

### 批量操作

```java
// ✅ 推荐：批量插入
this.saveBatch(userList, 1000);

// ✅ 推荐：批量更新
this.pdateBatchById(userList, 1000);

// ✅ 推荐：批量删除
this.removeByIds(userIds);
```

## 禁止使用的功能

### 数据库特定功能（严格禁止）

- ❌ **递归查询**：`WITH RECURSIVE`
- ❌ **多表联合查询**：`JOIN` 语句
- ❌ **数据库函数**：`DATE_FORMAT`、`CONCAT` 等
- ❌ **存储过程**：`CALL procedure_name`
- ❌ **触发器依赖**
- ❌ **窗口函数**：`ROW_NUMBER() OVER()`

### 复杂 SQL（避免使用）

- ❌ **复杂动态 SQL**：`<script>` 标签
- ❌ **复杂子查询**
- ❌ **多层嵌套查询**

## 检查清单

在编写 MyBatis Plus 代码时，请确保：

### Mapper 接口检查

- [ ] 继承了 `BaseMapper<T>`
- [ ] 添加了 `@Mapper` 注解
- [ ] 方法命名符合规范
- [ ] 使用了 `@Param` 注解
- [ ] 优先使用 Wrapper 而非手写 SQL
- [ ] 没有使用数据库特定功能

### Service 层检查

- [ ] 继承了 `ServiceImpl<Mapper, Entity>`
- [ ] 添加了事务注解
- [ ] 查询条件构建合理
- [ ] 包含适当的日志记录

### 性能检查

- [ ] 查询使用了索引字段
- [ ] 避免了全表扫描
- [ ] 批量操作使用了批量方法
- [ ] 分页查询设置了合理的限制

### 安全检查

- [ ] 使用了参数化查询
- [ ] 没有 SQL 注入风险
- [ ] 输入参数进行了验证
- [ ] 敏感操作记录了日志
