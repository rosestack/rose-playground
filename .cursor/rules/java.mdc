---
globs: *
alwaysApply: true
---

# Java 开发者 Cursor 用户规则

## 项目背景

我是一个 Java 开发者，正在开发各种 Java 项目。主要专注于后端开发，包括 Spring Boot 应用、微服务架构、企业级应用等。项目类型涵盖
Web 应用、API 服务、数据处理、系统集成等。

## 技术栈

### 后端技术栈

**核心框架：**

- **Java 17+**：使用最新的Java特性，如记录类、模式匹配等
- **Spring Boot 3.5+**：主框架，提供依赖注入和自动配置
- **Spring Security 6.x**：安全框架，处理认证和授权
- **MyBatis Plus 3.x**：数据访问层ORM框架，提供强大的查询能力

**数据存储：**

- **MySQL 8.0**：主数据库，支持JSON字段和窗口函数。使用 mysql-connector-j jdbc 驱动。
- **HikariCP**：高性能数据库连接池
- **Redis 7.x**：缓存和会话存储，支持多种数据结构
- **Elasticsearch**：搜索引擎，用于复杂查询和全文搜索

**构建和部署：**

- **Maven 3.9+**：构建工具和依赖管理
- **Docker**：容器化部署
- **Docker Compose**：本地开发环境编排

**监控和运维：**

- **Spring Boot Actuator**：应用监控和健康检查
- **Micrometer**：指标收集
- **Logback**：日志框架

**测试框架：**

- **JUnit 5**：单元测试框架，支持参数化测试和动态测试
- **Mockito 5.x**：模拟框架，用于创建测试替身
- **AssertJ**：流式断言库，提供更好的测试可读性
- **TestContainers**：集成测试容器，支持真实数据库和中间件测试
- **Spring Boot Test**：Spring Boot测试支持，包含各种测试切片
- **WireMock**：HTTP服务模拟，用于外部API测试
- **Testcontainers-JUnit5**：JUnit5与TestContainers集成

**开发工具：**

- **Lombok**：减少样板代码，自动生成getter/setter等
- **Spring Boot DevTools**：开发时热重载和自动重启
- **Swagger/OpenAPI 3**：API文档生成和在线测试
- **Spring Boot Configuration Processor**：配置元数据生成
- **MapStruct**：对象映射工具，编译时生成映射代码
- **Spotless**：代码格式化工具，保持代码风格一致
- **ArchUnit**：架构测试工具，验证架构规则

**工具库：**

- **Apache Commons Lang3**：通用工具类库
- **Jackson**：JSON序列化和反序列化
- **Validation API**：参数校验
- **Guava**：Google核心库，提供集合、缓存、并发等工具

**禁止使用的依赖：**

- **Hutool**：避免过度依赖工具库，保持代码的可控性
- **Fastjson**：存在安全风险，使用Jackson替代
- **Spring Data JPA**：与MyBatis Plus冲突，统一使用MyBatis Plus
- **Apache Commons BeanUtils**：性能较差，使用MapStruct替代
- **Dozer**：映射性能差，使用MapStruct替代
- **ModelMapper**：运行时映射，性能不如编译时的MapStruct
- **Gson**：功能不如Jackson完善，统一使用Jackson
- **Log4j 1.x**：已停止维护且存在安全漏洞，使用Logback
- **Commons Logging**：桥接复杂，直接使用SLF4J
- **Quartz**：过于重量级，简单任务使用Spring Task
- **Ehcache 2.x**：版本过旧，使用Caffeine或Redis
- **Jedis**：连接池管理复杂，使用Spring Data Redis
- **HttpClient 4.x**：版本过旧，使用Spring WebClient或OkHttp
- **Swagger 2.x**：已过时，使用OpenAPI 3
- **JUnit 4**：功能有限，使用JUnit 5
- **Hamcrest**：断言不够流畅，使用AssertJ
- **PowerMock**：与现代JVM不兼容，重构代码以支持Mockito

## 编码规范

### Java 编码规范

#### 1. 命名规范

- **类名**：使用 PascalCase，如 `UserService`、`OrderController`
- **方法名**：使用 camelCase，如 `getUserById`、`createOrder`
- **变量名**：使用 camelCase，如 `userName`、`orderList`
- **常量名**：使用 UPPER_SNAKE_CASE，如 `MAX_RETRY_COUNT`、`DEFAULT_TIMEOUT`
- **包名**：使用小写字母，如 `com.example.user`、`io.github.rose.security`

#### 2. 代码组织

- **DDD 分层架构**：`application`、`domain`、`infrastructure`、`interfaces`
- **单一职责**：每个类和方法只负责一个功能
- **依赖注入**：使用构造函数注入，避免字段注入
- **接口分离**：为服务层定义接口，实现类添加 `Impl` 后缀
- **代码生成**: 使用 **Lombok** 减少样板代码，自动生成getter/setter等

#### 3. 注释规范

- **语言**：所有注释必须使用中文，如果存在旧注释请先删除
- **格式**：使用标准 **JavaDoc** 格式（/** ... */）
- **范围**：为类、接口、枚举、方法、重要字段添加注释
- **内容原则**：避免冗余和过度描述，突出重点
- **必要的警告**：标记重要注意事项
- **避免废话**：不要注释显而易见的内容
- **保持更新**：代码变更时同步更新注释

**类/接口/枚举注释模板：**

```java
/**
 * [类/接口/枚举]的简要描述（一句话概括其用途）
 * <p>
 * 简要说明主要职责和功能，避免过多细节。
 * <p>
 * <h3>核心特性：</h3>
 * <ul>
 *   <li>特性一</li>
 *   <li>特性二</li>
 * </ul>
 *
 * @author 作者名
 * @since 引入版本
 * @see 相关类的引用
 */
```

**方法注释模板：**

```java
/**
 * 方法的简要描述（一句话概括其功能）
 *
 * @param 参数名 参数的简要描述
 * @return 返回值的简要描述（如果方法返回void则省略）
 * @throws 异常类名 抛出此异常的条件
 */
```

**字段注释模板：**

```java
/** 字段的简要描述，包括其用途 */
private Type fieldName;
```

**枚举值注释模板：**

```java
/** 枚举常量的简要描述 */
ENUM_VALUE,
```

#### 4. 异常处理

- **自定义异常**：为业务异常创建自定义异常类
- **统一异常处理**：使用 `@ControllerAdvice` 全局处理异常
- **日志记录**：记录异常信息和堆栈跟踪，包含足够上下文
- **用户友好**：返回用户友好的错误信息
- **异常只用于异常场景**：仅在异常情况下抛出异常，勿用于正常流程控制
- **捕获具体异常类型**：优先捕获具体异常，便于差异化处理
- **禁止吞异常**：禁止无处理地吞掉异常，否则难以排查
- **重试机制**：为瞬态错误实现重试机制

### Spring Boot 最佳实践

#### 1. 配置管理

- **外部化配置**：使用 `application.yml` 进行配置
- **配置属性类**：使用 `@ConfigurationProperties` 绑定配置
- **环境区分**：使用 `application-{profile}.yml` 区分环境
- **敏感信息**：使用环境变量或配置中心管理敏感信息

#### 2. 数据访问

- **仓储模式**：使用 DDD 仓储模式，在领域层定义接口，在基础设施层实现
- **Mapper 模式**：使用 MyBatis Plus Mapper 实现仓储
- **事务管理**：在应用层使用 `@Transactional(rollbackFor = Exception.class)`
- **查询优化**：使用索引、分页、缓存优化查询性能，避免 N+1 查询
- **数据验证**：使用 JSR-303 Bean Validation，结合 `@Validated`、`@Valid` 注解
- **连接池**：配置合适的数据库连接池参数
- **懒加载**：使用数据访问技术提供的懒加载功能

#### 3. 安全配置

- **JWT 认证**：使用 JWT 进行无状态认证
- **RBAC 权限**：实现基于角色的访问控制
- **多租户隔离**：支持多租户数据隔离
- **安全审计**：记录安全相关操作日志
- **输入验证**：使用白名单验证、正则表达式、数据类型验证
- **SQL 注入防护**：使用参数化查询或 ORM 框架
- **XSS 防护**：清理用户输入并使用输出编码
- **CSRF 防护**：使用 CSRF 令牌防止跨站请求伪造
- **速率限制**：实施速率限制防止滥用
- **加密传输**：使用 HTTPS 和 TLS/SSL 加密传输数据

### 
## 项目结构

### 常见项目结构

#### 1. DDD 分层架构结构

```
src/
├── main/
│   ├── java/
│   │   └── com/example/app/
│   │       ├── Application.java
│   │       ├── interfaces/      # 接口层（控制器、DTO）
│   │       │   ├── controller/  # REST 控制器
│   │       │   ├── dto/         # 数据传输对象
│   │       │   └── assembler/   # DTO 转换器
│   │       ├── application/     # 应用层（应用服务、命令、查询）
│   │       │   ├── service/     # 应用服务
│   │       │   ├── command/     # 命令对象
│   │       │   ├── query/       # 查询对象
│   │       │   └── event/       # 应用事件
│   │       ├── domain/          # 领域层（实体、值对象、领域服务）
│   │       │   ├── entity/      # 领域实体
│   │       │   ├── valueobject/ # 值对象
│   │       │   ├── service/     # 领域服务
│   │       │   ├── repository/  # 仓储接口
│   │       │   └── event/       # 领域事件
│   │       ├── infrastructure/  # 基础设施层（持久化、外部服务）
│   │       │   ├── persistence/ # 持久化实现
│   │       │   │   ├── mapper/  # MyBatis Mapper
│   │       │   │   ├── entity/  # 数据库实体
│   │       │   │   └── converter/ # 实体转换器
│   │       │   ├── config/      # 配置类
│   │       │   ├── external/    # 外部服务集成
│   │       │   └── util/        # 工具类
│   │       └── shared/          # 共享层（通用组件）
│   │           ├── exception/   # 异常处理
│   │           ├── constant/    # 常量定义
│   │           └── util/        # 通用工具
│   └── resources/
│       ├── application.yml
│       ├── mapper/              # MyBatis XML 映射文件
│       └── static/
└── test/
    └── java/
        └── com/example/app/
```

#### 2. DDD 微服务项目结构

```
project/
├── shared/                        # 共享模块
│   ├── shared-domain/             # 共享领域模型
│   ├── shared-infrastructure/     # 共享基础设施
│   └── shared-application/        # 共享应用服务
├── user-service/                  # 用户服务（按 DDD 分层）
│   ├── interfaces/
│   ├── application/
│   ├── domain/
│   └── infrastructure/
├── order-service/                 # 订单服务（按 DDD 分层）
│   ├── interfaces/
│   ├── application/
│   ├── domain/
│   └── infrastructure/
├── payment-service/               # 支付服务（按 DDD 分层）
│   ├── interfaces/
│   ├── application/
│   ├── domain/
│   └── infrastructure/
├── gateway-service/               # 网关服务
└── config-service/                # 配置服务
```

#### 3. DDD 多模块项目结构

```
project/
├── interfaces/                    # 接口层模块
│   ├── web/                       # Web 接口
│   ├── api/                       # API 接口
│   └── dto/                       # 数据传输对象
├── application/                   # 应用层模块
│   ├── service/                   # 应用服务
│   ├── command/                   # 命令处理
│   └── query/                     # 查询处理
├── domain/                        # 领域层模块
│   ├── entity/                    # 领域实体
│   ├── service/                   # 领域服务
│   └── repository/                # 仓储接口
├── infrastructure/                # 基础设施层模块
│   ├── persistence/               # 持久化实现
│   ├── external/                  # 外部服务
│   └── config/                    # 配置
└── shared/                        # 共享模块
    ├── domain/                    # 共享领域
    ├── infrastructure/            # 共享基础设施
    └── util/                      # 通用工具
```

## 开发工作流

### 1. 功能开发流程

1. **需求分析**：理解业务需求和技术要求
2. **设计阶段**：设计 API 接口、数据库表结构、服务架构
3. **开发阶段**：按模块并行开发，遵循 TDD 原则
4. **测试阶段**：单元测试、集成测试、API 测试
5. **代码审查**：提交 PR，进行代码审查
6. **部署阶段**：部署到测试环境，进行功能验证

### 2. 全栈开发流程（如有前端）

1. **需求分析**：理解业务需求和技术要求
2. **架构设计**：设计系统架构、API 接口、数据库表结构
3. **后端开发**：开发 API 服务、数据处理、业务逻辑
4. **前端开发**：开发用户界面、交互逻辑、数据展示
5. **集成测试**：前后端联调、端到端测试
6. **部署上线**：部署到生产环境，监控运行状态

### 3. Git 工作流

- **分支策略**：使用 Git Flow 或 GitHub Flow
- **提交规范**：使用约定式提交（Conventional Commits）
    - **类型**：feature（新功能）、fix（修复）、refactor（重构）、others（其他）
    - **描述**：简明扼要说明变更内容，使用祈使句
    - **正文**：详细阐述变更原因和背景
- **原子性提交**：每次提交只包含一个独立、完整的逻辑变更
- **频繁提交**：及时提交，减少丢失进度风险
- **PR 模板**：使用标准的 PR 模板
- **代码审查**：所有代码变更需要经过审查
- **禁止直推主分支**：对主分支的所有更改必须通过 Pull Request 合并
- **敏感信息管理**：严禁提交密钥、密码、API Key 等敏感信息

### 4. 测试策略

- **单元测试**：使用 JUnit 5 + Mockito，覆盖率 > 80%
    - **测试驱动开发（TDD）**：在编写代码之前编写测试
    - **测试命名**：使用清晰且描述性的测试名称
    - **安排-操作-断言**：使用 AAA 模式结构化测试
- **集成测试**：使用 Spring Boot 测试切片（`@WebMvcTest`、`@DataJpaTest`）
- **API 测试**：使用 Postman 或 RestAssured 测试 API 接口
- **端到端测试**：如有前端，使用 Selenium 或无头浏览器测试
- **性能测试**：测试系统性能和并发能力
- **TestContainers**：与真实依赖（数据库、消息队列）一起运行集成测试
- **避免过度模拟**：仅模拟必要的依赖以隔离被测单元

## 代码质量

### 1. 静态代码分析

- **SonarQube**：代码质量分析
- **SpotBugs**：Bug 检测
- **Checkstyle**：代码风格检查
- **PMD**：代码复杂度分析

### 2. 代码格式化

- **IDE 配置**：使用统一的 IDE 配置
- **代码模板**：使用代码模板提高开发效率
- **自动格式化**：提交前自动格式化代码

### 3. 文档规范

- **API 文档**：使用 Swagger/OpenAPI 生成 API 文档
- **代码文档**：使用 JavaDoc 生成代码文档
- **架构文档**：维护系统架构和设计文档
- **部署文档**：维护部署和运维文档

## 性能优化

### 1. 数据库优化

- **索引优化**：为查询字段创建合适的索引
- **查询优化**：优化 SQL 查询，避免 N+1 问题
- **连接池**：配置合适的数据库连接池
- **分页查询**：大数据量查询使用分页

### 2. 缓存策略

- **Redis 缓存**：缓存热点数据和计算结果
- **本地缓存**：使用 Caffeine 进行本地缓存
- **缓存更新**：实现缓存更新和失效策略
- **缓存监控**：监控缓存命中率和性能

### 3. 异步处理

- **异步任务**：使用 `@Async` 处理耗时任务
- **消息队列**：使用消息队列处理异步消息
- **线程池**：配置合适的线程池参数
- **超时处理**：设置合理的超时时间
- **懒加载策略**：仅在首次访问时初始化对象
- **对象池**：使用对象池复用对象并减少创建开销
- **避免内存泄漏**：确保对象能够被正确垃圾回收

## 学习资源

### 1. 官方文档

- [Spring Boot 官方文档](https://spring.io/projects/spring-boot)
- [Spring Security 官方文档](https://spring.io/projects/spring-security)
- [MyBatis Plus 官方文档](https://baomidou.com/)
- [Java 官方文档](https://docs.oracle.com/en/java/)

### 2. 最佳实践

- [Spring Boot 最佳实践](https://spring.io/guides)
- [Java 编码规范](https://google.github.io/styleguide/javaguide.html)
- [REST API 设计指南](https://restfulapi.net/)
- [Spring Security 最佳实践](https://spring.io/projects/spring-security)
- [DDD 领域驱动设计](https://martinfowler.com/bliki/DomainDrivenDesign.html)


