---
type: "always_apply"
---

# 开发规范与代码质量

- **目标**：统一团队代码质量标准，提升可靠性、可维护性与安全性
- **适用范围**：Java 后端代码（含 Spring Boot、MyBatis Plus、MySql、Redis）
- **优先级**：强制遵循；代码评审与 CI 按此规则执行

## 一、通用工程原则

- **SOLID/DRY/KISS/YAGNI/关注点分离**：严格遵循，避免过度设计与重复实现
- **模块边界清晰**：控制器仅处理 HTTP/校验/响应封装；业务在服务层；数据访问在 Mapper
- **向后兼容**：新增面向扩展，禁止破坏既有对外契约（DTO、API、配置键）
- **失败即早**：非法参数立即校验并抛出；避免静默失败

## 二、代码风格与复杂度

* **命名**
    - 包：`com.company.project.module`
    - 类：`XXService/XXServiceImpl/XXController/XXMapper/XXEntity`。类名使用单数，不要使用复数。
    - 方法：查询 `getBy*/findBy*/list*/page*/countBy*`；判断 `is/exists/has`；操作 `create*/update*/delete*`
    - 变量：语义化、用完整单词；常量全大写下划线
* **结构**
    - 单文件 ≤ 500 行；单方法 ≤ 50 行；圈复杂度 ≤ 10；方法参数 ≤ 5 个
    - 优先早返回；避免 3 层以上深度嵌套
    - 代码块需要添加花括号
* **注释**
    - 复杂业务/非直观逻辑必须中文注释，写“为什么”不是“怎么做”
    - 公共接口/DTO/异常类添加 Javadoc
* **格式化**
    - 由 Spotless 管控；提交前必须通过 `mvn spotless:apply`；在 `-Pquality` 下强制执行
* **语言与数据类型**
    - Lombok：禁止在实体类上使用 @Data，推荐 @Getter/@Setter/@Builder；显式 equals/hashCode 策略避免主键/延迟加载陷阱。
    - 时间：统一使用 UTC 存储；边界层（Controller/外部接口）进行时区转换；优先使用 Instant/ZonedDateTime 表达时间含义。
    - 金额：统一使用 BigDecimal，约定精度与舍入模式；禁止使用浮点类型表示金额。

## 三、Spring Boot 规范

### 1. 依赖注入与组件可见性

* 统一使用构造器注入，依赖字段 final；禁止字段/Setter 注入。
* 如果只有一个构造函数，Spring 将自动检测，无需在构造函数上添加 `@Autowired`。
* 避免在生产代码中注入字段/设置器。
* 组件默认 package-private，可见性最小化；仅暴露必要 Bean。
* Prototype/Request/Session Scope 使用受控；禁止在多线程持有非单例 Bean。

### 2. 配置管理清单

* application.yaml 按环境分层；敏感配置通过环境变量/密钥管理器注入；禁写入仓库与日志；业务参数优先用配置（如 Redis
  TTL），不在代码中硬编码。
* 所有自定义配置绑定到 @ConfigurationProperties，使用 @Validated 进行约束校验，提供默认值。
* 禁止零散 @Value 注入；统一前缀分组，文档化配置项与默认值。

### 3. 线程池与超时基线

* 超时基线：
    - HTTP 客户端：连接 500ms、读取 2s；
    - 数据库：连接超时 2s、查询超时 2-5s（按场景）；
    - Redis：命令超时 1s；
    - 跨服务调用必须设置超时与重试上限。
* 参数外置：所有超时与线程池参数必须通过配置暴露，按环境覆盖；禁止硬编码。

### 4. 事务边界

* 读操作显式 @Transactional(readOnly = true)；写操作 @Transactional(rollbackFor = Exception.class)。
* 事务范围最小化；禁止在单事务内发起远程调用；必要时采用补偿/Saga。
* 只在 Service 层定义事务；Controller/DAO 层不直接控制事务。

### 5. Web 层一致性

* Controller 保持瘦身：无业务逻辑；DTO + Jakarta Validation。
* 分页统一使用 MyBatis-Plus 的 `Page` 模型：Controller/Service 入参采用 `Page<?>`对象，返回 `Page<T>`；禁止直接返回实体。
* 使用命令对象（例如“CreateOrderCommand”）进行业务操作

### 6. 遵循 REST API 设计原则

* **版本化、面向资源的 URL：**将您的端点构造为 `/api/v{version}/resources`（例如 `/api/v1/orders`）。
* **集合和子资源的一致模式**：保持 URL 约定统一（例如，帖子集合使用 `/posts`，特定帖子的评论使用 `/posts/{slug}/comments`）。
* 分页约束：默认 pageSize=20，最大不超过 100；禁止无上限拉取。
* 排序约束：采用白名单字段与默认稳定排序；禁止直接透传数据库字段名。
* 幂等性：对关键 POST/支付/订单等操作，客户端需提供 Idempotency-Key；服务端在 5-10 分钟窗口内去重并返回首次结果。

### 7. 安全

* Spring Security 最小权限：启用方法级鉴权（@PreAuthorize），细粒度基于角色/权限串；
* 认证与会话：推荐 JWT/OAuth2，签名密钥轮换；令牌最短可用期与刷新策略明确；
* 秘密与凭据：集中管理（Vault/环境变量），git/secrets 扫描；禁止在日志/配置中明文；
* 输入输出安全：XSS/SQL 注入/路径遍历防护；文件上传大小/类型限制与存储隔离；CORS 最小化策略。

### 8. 国际化

* 将所有面向用户的文本（如标签、提示和消息）外部化到 ResourceBundles 中，而不是将它们嵌入到代码中。

### 9. 日志与可观测性

日志：
* 切勿使用 `System.out.println()` 进行应用程序日志记录，使用 SLF4J + Logback。
* 严禁打印敏感信息；必要时脱敏（手机号、邮箱、证件号等）。
* 日志分级：ERROR/WARN/INFO/DEBUG；异常日志必须含上下文与堆栈。
* 调试日志包装 isDebugEnabled。
* TraceId 贯穿；日志中透传 MDC/traceId；可选启用虚拟线程需验证 MDC 透传。

可观测性：
* Actuator 仅开放 /health /info /metrics；其余需鉴权。
* 优雅停机、Readiness/Liveness 探针配置完备并通过演练。
* 为关键操作添加业务埋点、指标与告警阈值。建议使用 Micrometer + Spring Boot Actuator 暴露指标。

### 10. 测试与门禁

* 单元/集成/契约测试覆盖率符合项目阈值；使用 Testcontainers 启动真实依赖。
* 构建中开启 Sonar（SonarQube/SonarCloud）、Spotless、JaCoCo，违规即失败；不降低阈值。
* 使用随机端口进行集成测试

### 11. 版本与依赖管理

* Java 与构建基线：最低 JDK 版本为 Java 21（LTS）；Maven 使用 Toolchains 或 maven-compiler-plugin（release/target=21），Gradle 使用 Java Toolchains（sourceCompatibility/targetCompatibility=21）；启用 spring-boot-configuration-processor 生成配置元数据。
* 使用父 POM/BOM 锁定版本：Spring Boot 3.5.x、Spring Cloud 2025.0.x、MyBatis-Plus 3.5.12+。
* 根 POM 统一 properties 管理版本（如 spring-boot.version、spring-cloud.version、mybatis-plus.version）。
* 建立依赖升级机制：优先使用 Renovate（或月度人工巡检），禁止长期滞后。

### 12. 本地依赖与编排

* 仓库根提供 docker-compose.yaml 与 .env.example，包含 MySQL/Redis/RabbitMQ 的默认配置与持久化卷。
* 构建镜像可使用 spring-boot-maven-plugin 的 build-image（Paketo Buildpacks），无需 Dockerfile；如需高级定制可保留
  Dockerfile。
* 禁止提交生产凭据；敏感变量通过环境注入。

## 四、MyBatis Plus 规范

### 1. 实体与映射

* @TableName/@TableId/@TableField 映射完整；字段命名与数据库下划线一致（自动驼峰转换确认）。
* 逻辑删除（@TableLogic）、乐观锁（@Version）、审计字段（createTime/updateTime）策略已配置并生效。
* MyBatis-Plus 自动填充（MetaObjectHandler）用于审计字段；避免在业务代码手工维护时间。
* 严禁实体包含业务逻辑；禁止循环/双向膨胀关联；关联通过明确查询实现。

### 2. Mapper 与 XML

* 严禁使用注解式 SQL（@Select/@Update/@Delete/@Insert 等）；统一使用 MyBatis-Plus 提供的方法与 Wrapper 条件构造。
* 严禁编写 Mapper XML 与动态 SQL；保持持久层简单、可维护、与数据库弱绑定。

### 3. 查询与分页

* 分页统一使用 MyBatis-Plus 分页插件；禁止手写 limit 偏移造成全表扫描。（自 v3.5.9 起需引入 `mybatis-plus-jsqlparser`
  依赖以启用 `PaginationInnerInterceptor`）。
* 必须注册 MybatisPlusInterceptor：包含
  PaginationInnerInterceptor、OptimisticLockerInnerInterceptor（@Version）、BlockAttackInnerInterceptor（防止全表更新/删除）。
* 条件构造统一使用 LambdaQueryWrapper/LambdaUpdateWrapper；避免字符串拼 SQL 与注入风险。
* 逻辑删除已开启时，严禁在条件构造中手动添加 deleted/is_deleted 等逻辑删除字段条件；框架自动处理。
* 大结果集采用游标/流式处理或分片拉取；查询超时与最大行数限制已配置。

### 4. 写入与批处理

* 批量写入使用 saveBatch()/ExecutorType.BATCH；控制批大小（如 500-1000）与事务边界；避免 OOM。
* 插入/更新仅写必要字段，避免全字段更新；更新语句 set 列表使用 <set> 自动去空。
* 唯一约束冲突有幂等处理（如 upsert/先查后插/分布式锁）。

### 5. 事务与一致性

* Service 层方法具备明确事务注解；跨资源使用最终一致性/补偿方案；禁止在事务内远程调用。
* 主键生成策略统一（雪花/序列/DB 自增）；时区与时序一致性校验（UTC 存储）。

### 6. 性能与监控

* 启用 MyBatis 日志/慢 SQL 监控；对慢查询建立告警与基线（TP90/TP99）。
* HikariCP 连接池参数依据负载与 DB 限额配置；池耗尽保护与指标上报到可观测平台。

## 五、MySQL 规范

### 1. 表与字段设计

* 表名使用英文小写+下划线，单数形式（如 user 非 users）；避免 MySQL 保留字；每个表有主键。
* 字段命名简洁明了，使用英文小写+下划线；避免冗余前缀；主键统一 id；时间字段 created_time/updated_time。
* 字符集统一 utf8mb4；排序规则统一 utf8mb4_general_ci；根据数据范围选择合适类型（TINYINT/SMALLINT/INT/BIGINT）；金额字段使用
  DECIMAL。
* 重要字段 NOT NULL 约束；表和字段有 COMMENT 注释；遵循第三范式避免数据冗余。
* 运行参数：binlog_format=ROW，sql_mode=STRICT_TRANS_TABLES；统一时区 UTC；隔离级别 REPEATABLE READ。

### 2. 索引设计与优化

* 索引命名规范：idx_表名_字段名（单字段）、idx_表名_字段1_字段2（复合）、uk_表名_字段名（唯一）。
* 复合索引字段顺序考虑查询频率与选择性；避免创建重复索引。
* 禁用外键约束，但保留外键列与相应索引以保障查询性能与数据治理。
* 查询覆盖索引使用；长字段前缀索引；避免 SELECT *；WHERE/ORDER BY/GROUP BY 字段有索引支撑。

### 3. SQL 性能与规范

* 慢 SQL 监控与优化：查询时间超过 1s 告警；使用 EXPLAIN 分析执行计划；避免全表扫描。
* 禁止在 WHERE 中使用函数、隐式类型转换、前缀模糊查询；合理使用 LIMIT 分页。
* 批量操作控制大小（如 500-1000 行）；大表 DDL 变更使用在线工具（gh-ost/pt-online-schema-change）。

### 4. 事务与并发控制

* 事务范围最小化；避免长事务锁表；读写分离场景注意主从延迟一致性。
* 死锁检测与重试机制；高并发场景使用乐观锁（版本号）或分布式锁。
* 事务隔离级别与业务场景匹配；避免幻读与不可重复读问题。

### 5. 容量规划与监控

* 表容量预估与分片策略（垂直/水平）；单表行数控制在合理范围（建议 < 500w）。
* 监控指标：QPS/TPS、慢查询数量、连接数、锁等待、主从延迟；设置告警阈值。
* 定期备份与恢复演练；binlog 保留策略；数据归档与清理机制。

### 6. 安全与合规

* 数据库权限最小化；敏感字段加密存储；访问审计日志完备。
* SQL 注入防护；输入参数化查询；避免动态 SQL 拼接。
* 生产环境禁止 DDL 直接操作；变更通过工单与审核流程。

## 六、Redis 规范

适用范围：Spring Data Redis/Redisson 在缓存、锁、消息等场景的使用。

### 1. Key 设计与序列化

* Key 统一前缀：`{env}:{app}:{domain}:{resource}:{id}`，避免高基数字段进入前缀；
* 统一序列化：StringRedisSerializer + Jackson2JsonRedisSerializer；禁用 JDK 序列化。Jackson2JsonRedisSerializer：注册 JavaTimeModule、禁用默认类型信息，显式序列化；
* JSON 序列化字段显式版本控制（@JsonTypeInfo 禁用）；兼容性升级策略明确。

### 2. TTL 与容量管理

* 所有缓存写入设置 TTL，默认不超过 7 天；不同类型数据有独立 TTL 策略与随机抖动；TTL 应通过 `application.yaml` 配置（如
  `spring.cache.redis.time-to-live`），禁止在代码中硬编码。
* 缓存 TTL 建议增加 5%-10% 随机抖动；Lettuce 客户端应配置 command timeout、连接池（max-active/max-idle/min-idle）。
* 内存水位监控与淘汰策略配置（建议 allkeys-lru/lfu）；超阈值报警。
* 禁止在生产路径使用 KEYS/SCAN 大范围遍历；后台工具类库进行维护操作。

### 3. 缓存三难问题防护

* 雪崩：TTL 加随机、预热热点、分散重建；必要时使用多级缓存（Caffeine + Redis）。
* 穿透：对不存在的 key 缓存空值（短 TTL），或引入布隆过滤器。
* 击穿：热点 key 使用互斥锁/逻辑过期防抖；异步重建与过期兜底。

### 4. 分布式锁与并发

* 分布式锁使用 Redisson 或原子 set nx px + 校验释放；超时时间与业务耗时匹配；避免死锁。
* 锁粒度与范围可控；不可重入场景显式限制；失败与重试策略明确。

### 5. 一致性与回源策略

* DB 写 -> 删缓存 -> 最终一致性修复（Binlog/消息）；避免先删后写的竞态。
* 双写或订阅机制具备幂等与去重；异常场景有回滚或重建策略。

### 6. 监控与告警

* 指标：命中率、QPS、慢查询、失败率、连接池、命令超时；可视化与告警。
* 异常：连接超时、反序列化失败、内存不足等都应有明确日志与 retry/backoff。

## 七、OpenFeign 规范

适用范围：OpenFeign + Spring Cloud CircuitBreaker/Resilience4j 调用外部/内部服务。

### 1. 客户端超时与重试

* 为每个 FeignClient 设置连接/读超时（例如 500ms/2s，视业务调整）；禁用全局无限超时。明确 HTTP 客户端（OkHttp 或 Apache
  HttpClient5）与连接池参数。
* 重试仅用于幂等 GET/HEAD；限制重试次数与退避策略；对 POST/PUT 默认不重试。

### 2. 熔断、隔离与降级

* 使用 Resilience4j/Spring Cloud CircuitBreaker：配置超时、舱壁隔离、熔断窗口与阈值。
* 为关键接口提供降级实现或兜底响应；降级路径记录可观测性指标与告警。

### 3. 负载均衡与路由

* 使用 Spring Cloud LoadBalancer；超时与重试策略与服务注册信息一致；避免跨区域高延迟调用。
* 对多区域/多版本服务实施基于标头/标签的路由策略；灰度/金丝雀具备回滚预案。

### 4. API 契约与错误处理

* DTO 与错误码契约化，不泄露内部模型；兼容性按最小可用原则演进（新增字段向后兼容）。
* HTTP 状态码与业务错误码映射明确；对 4xx/5xx 分类处理并有清晰日志上下文。
* 使用 ErrorDecoder 统一解析远端异常；调用侧转译为业务异常并带上 traceId。

### 5. 安全与合规

* 认证凭据通过安全渠道注入（Header/Token）；不在日志中打印敏感数据；最小权限访问下游。
* 幂等保障：对外部接口在调用侧引入幂等键/防重复提交；对支付/订单等关键接口重点校验。

### 6. 测试与可观测性

* 契约/集成测试覆盖：正常/超时/熔断/降级/重试/限流等路径；使用 WireMock/MockWebServer。
* 指标：成功率、延迟分位（TP90/TP99）、熔断打开率、重试次数、降级次数；异常比率告警。

## 八、异常处理与错误管理

### 1. 异常分层与传播

* 异常分层：系统异常（SystemException）、业务异常（BusinessException）、参数异常（ValidationException）、外部异常（ExternalException）。
* 异常传播：Controller 层统一捕获并转换为标准响应；Service 层抛出业务异常；DAO 层异常向上传播。
* 异常日志：ERROR 级别记录系统异常和外部异常；WARN 级别记录业务异常；包含完整堆栈和上下文信息。

### 2. 全局异常处理

* 使用 @RestControllerAdvice 统一处理异常；区分不同异常类型返回对应错误码。
* 统一响应：`ApiResponse<T>`（不采用 RFC7807），字段包括 code（Integer）、message（String，可国际化）、data（泛型，可为 null）、success（boolean）。
    - 错误码分配：0（成功）；1000-1999（校验/客户端）；2000-2999（业务规则）；3000-3999（鉴权/权限）；4000-4999（资源/配额/并发冲突）；5000-5999（下游/外部系统）；9000-9999（系统内部错误）。
    - 每个模块维护错误码清单（README 或 docs/error-codes.md），避免冲突；traceId 通过响应头（如 X-Trace-Id）透传，必要时在响应体回显。
    - 敏感信息不暴露给前端
* 参数校验异常统一处理：@Valid/@Validated 校验失败返回详细字段错误信息。

### 3. 重试与容错

* 对于外部服务调用，实施指数退避重试策略；设置最大重试次数和超时时间。
* 使用 @Retryable 或 Resilience4j 实现重试；仅对幂等操作和临时性错误进行重试。
* 提供降级和熔断机制；关键业务路径有备选方案。

## 九、消息队列规范

适用范围：RabbitMQ/Kafka/RocketMQ 等消息中间件的使用。

### 1. 消息设计与序列化

* 消息体使用 JSON 格式，包含：消息ID、时间戳、版本号、业务数据、元数据。
* 消息 ID 全局唯一，支持消息去重和幂等处理；时间戳使用 UTC 格式。
* 消息版本化：支持向后兼容的消息结构演进；废弃字段保留一段时间后移除。

### 2. 可靠性保障

* 生产者确认：启用发布确认机制，确保消息成功投递到 Broker。
* 消费者确认：使用手动确认模式；处理成功后确认，失败时拒绝并重新入队或转入死信队列。
* 消息持久化：重要消息设置持久化；队列和交换机设置持久化标志。

### 3. 死信与重试

* 死信队列：为每个业务队列配置死信队列；达到重试上限的消息转入死信队列。
* 重试策略：设置合理的重试间隔和最大重试次数；区分临时性错误和永久性错误。
* 监控告警：死信队列堆积、消费延迟、错误率等指标告警。

### 4. 性能与容量

* 批量处理：支持批量消费和批量确认；控制批次大小避免内存溢出。
* 背压控制：设置消费者预取数量；防止消费者过载导致内存问题。
* 分区策略：合理设计分区键；避免热点分区影响整体性能。

## 十、容器化与部署规范

### 1. Docker 镜像构建

* 使用多阶段构建：分离编译和运行环境；减少镜像体积。
* 基础镜像选择：优先使用官方镜像；定期更新基础镜像修复安全漏洞。
* 镜像标签：使用语义化版本标签；避免使用 latest 标签在生产环境。
* 镜像安全：定期扫描镜像漏洞；移除不必要的软件包和文件。

### 2. 容器运行时配置

* 资源限制：设置 CPU 和内存限制；避免容器消耗过多主机资源。
* 健康检查：配置 Readiness 和 Liveness 探针；确保容器状态正确。
* 环境变量：敏感信息通过 Secret 注入；配置信息通过 ConfigMap 管理。

### 3. 服务编排

* 使用 Docker Compose 进行本地开发环境编排；生产环境使用 Kubernetes。
* 服务依赖：明确服务间依赖关系；使用 depends_on 或 init containers。
* 网络配置：合理设计网络拓扑；服务间通信使用内部网络。

### 4. 持久化存储

* 数据卷管理：数据库数据使用命名卷；日志文件使用绑定挂载。
* 备份策略：重要数据定期备份；验证备份恢复流程。
* 权限控制：容器以非 root 用户运行；最小权限原则。

## 十一、微服务架构规范

### 1. 服务拆分与边界

* 服务拆分原则：按业务域拆分；单一职责原则；避免过度拆分。
* 服务边界：明确服务间的依赖关系；避免循环依赖。
* 数据一致性：每个服务管理自己的数据；跨服务数据通过事件同步。

### 2. 服务发现与注册

* 使用服务注册中心（Eureka/Consul/Nacos）；服务启动时自动注册。
* 健康检查：定期检查服务健康状态；不健康服务自动下线。
* 负载均衡：使用客户端负载均衡；支持多种负载均衡策略。

### 3. API 网关

* 统一入口：所有外部请求通过 API 网关；内部服务间直接通信。
* 路由规则：基于路径、请求头等条件路由；支持版本控制和灰度发布。
* 横切关注点：认证授权、限流熔断、日志监控在网关层统一处理。

### 4. 配置管理

* 集中配置：使用配置中心管理所有服务配置；支持配置热更新。
* 环境隔离：不同环境使用不同配置；避免配置混乱。
* 敏感信息：使用加密存储；运行时解密。

## 十二、多租户架构规范

### 1. 租户隔离策略

* 数据隔离：支持共享数据库、共享 Schema、独立数据库三种模式；根据业务需求选择。
* 应用隔离：通过租户标识区分不同租户请求；确保数据不串户。
* 资源隔离：按租户分配计算和存储资源；支持弹性伸缩。

### 2. 租户上下文管理

* 上下文传递：请求全链路传递租户信息；使用 ThreadLocal 或 MDC。
* 权限校验：基于租户进行权限控制；确保数据访问安全。
* 审计日志：记录租户操作日志；支持按租户查询和统计。

### 3. 配置与定制化

* 租户配置：支持按租户自定义配置；热生效配置变更。
* 功能开关：按租户控制功能开关；支持灰度发布。
* UI 定制：支持租户品牌定制；主题和样式可配置。

## 十三、质量门禁与集成

* 静态检查：Sonar、Spotless（统一格式）已在 CI 启用；失败即阻断。
* 单元/集成/契约测试覆盖率门槛：核心模块 80%+，边缘模块 60%+；新增代码不得降低全局阈值。
* 性能基线：关键接口具备基准压测报告（TP90/TP99、错误率、CPU/内存），上线前回归。
* 安全扫描：集成依赖漏洞扫描、镜像安全扫描；高危漏洞阻断发布。
* 文档与变更：面向用户/API 的变更已在文档与变更日志中更新；运维手册同步。

## 十四、团队协作与开发流程

### 1. Git 工作流

* 分支策略：采用 GitFlow 或 GitHub Flow；保护主分支；强制 PR 评审。
* 提交规范：使用 Conventional Commits；自动生成变更日志。
* 代码评审：必须经过同行评审；关注代码质量、安全性、性能。

### 2. 持续集成

* 自动化构建：代码提交触发自动构建；包含编译、测试、静态检查。
* 质量门禁：不符合质量标准的代码不允许合并；自动化部署到测试环境。
* 回滚机制：支持快速回滚；保留多个版本部署能力。

### 3. 文档管理

* API 文档：使用 OpenAPI 自动生成；与代码同步更新。
* 架构文档：记录重要的架构决策；定期更新设计文档。
* 运维文档：部署、监控、故障处理手册；操作流程标准化。

—— 以上规则作为代码质量门禁，自动化校验与人工评审共同执行。若发现坏味道（僵化/冗余/循环依赖/脆弱/晦涩/数据泥团/不必要复杂），应立即提出优化建议并评估改造计划。
