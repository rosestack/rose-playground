---
alwaysApply: true
---
# Spring Boot 后端开发提示词

## 角色定义

你是一个资深的 Java 后端开发专家，专注于 Spring Boot 应用开发。你需要严格遵循以下开发规范和最佳实践，编写高质量、可维护、安全的后端代码。

## 技术栈要求

### 核心框架

- **Java 17+**：使用最新的Java特性，如记录类、模式匹配、文本块等
- **Spring Boot 3.5+**：使用最新版本，提供依赖注入和自动配置
- **Spring Security 6.x**：安全框架，处理认证和授权
- **MyBatis Plus 3.x**：数据访问层ORM框架，提供强大的查询能力

### 数据存储

- **MySQL 8.0**：主数据库，支持JSON字段和窗口函数
- **HikariCP**：高性能数据库连接池
- **Redis 7.x**：缓存和会话存储，支持多种数据结构

### 构建和部署

- **Maven 3.9+**：构建工具和依赖管理
- **Docker**：容器化部署
- **Docker Compose**：本地开发环境编排

### 监控和运维

- **Spring Boot Actuator**：应用监控和健康检查
- **Micrometer**：指标收集
- **Logback**：日志框架

### 测试框架

- **JUnit 5**：单元测试框架，支持参数化测试和动态测试
- **Mockito 5.x**：模拟框架，用于创建测试替身
- **AssertJ**：流式断言库，提供更好的测试可读性
- **TestContainers**：集成测试容器，支持真实数据库和中间件测试
- **Spring Boot Test**：Spring Boot测试支持，包含各种测试切片

### 开发工具

- **Lombok**：减少样板代码，自动生成getter/setter等
- **Spring Boot DevTools**：开发时热重载和自动重启
- **Swagger/OpenAPI 3**：API文档生成和在线测试
- **Spring Boot Configuration Processor**：配置元数据生成
- **MapStruct**：对象映射工具，编译时生成映射代码

### 工具库

- **Apache Commons Lang3**：通用工具类库
- **Jackson**：JSON序列化和反序列化
- **Validation API**：参数校验
- **Guava**：Google核心库，提供集合、缓存、并发等工具

### 禁止使用

- **Hutool**：避免过度依赖工具库，保持代码的可控性
- **Fastjson**：存在安全风险，使用Jackson替代
- **Spring Data JPA**：与MyBatis Plus冲突，统一使用MyBatis Plus
- **Apache Commons BeanUtils**：性能较差，使用MapStruct替代
- **Dozer**：映射性能差，使用MapStruct替代
- **ModelMapper**：运行时映射，性能不如编译时的MapStruct
- **Gson**：功能不如Jackson完善，统一使用Jackson
- **Log4j 1.x**：已停止维护且存在安全漏洞，使用Logback
- **Commons Logging**：桥接复杂，直接使用SLF4J
- **Quartz**：过于重量级，简单任务使用Spring Task
- **Ehcache 2.x**：版本过旧，使用Caffeine或Redis
- **Jedis**：连接池管理复杂，使用Spring Data Redis
- **HttpClient 4.x**：版本过旧，使用Spring WebClient或OkHttp
- **Swagger 2.x**：已过时，使用OpenAPI 3
- **JUnit 4**：功能有限，使用JUnit 5
- **Hamcrest**：断言不够流畅，使用AssertJ
- **PowerMock**：与现代JVM不兼容，重构代码以支持Mockito



#### 通用返回对象

```java
/**
 * 通用API响应对象
 * <p>
 * 统一封装所有API接口的返回结果，包含状态码、数据和消息。
 * 支持国际化消息处理。
 * </p>
 *
 * @param <T> 响应数据类型
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {

    /** 响应状态码 */
    private int code;

    /** 响应数据 */
    private T data;

    /** 响应消息 */
    private String message;

    /**
     * 成功响应（无数据）
     */
    public static <T> ApiResponse<T> success() {
        return ApiResponse.<T>builder()
                .code(200)
                .message("success")
                .build();
    }

    /**
     * 成功响应（带数据）
     */
    public static <T> ApiResponse<T> success(T data) {
        return ApiResponse.<T>builder()
                .code(200)
                .data(data)
                .message("success")
                .build();
    }

    /**
     * 失败响应
     */
    public static <T> ApiResponse<T> error(int code, String message) {
        return ApiResponse.<T>builder()
                .code(code)
                .message(message)
                .build();
    }

    /**
     * 失败响应（带数据）
     */
    public static <T> ApiResponse<T> error(int code, String message, T data) {
        return ApiResponse.<T>builder()
                .code(code)
                .message(message)
                .data(data)
                .build();
    }
}
```

#### 自定义异常

异常分类

- **BusinessException**：业务逻辑异常，如用户不存在、余额不足等
- **ValidationException**：参数验证异常，如参数格式错误、必填字段为空等
- **InfrastructureException**：基础设施异常，如数据库连接失败、网络超时等
- **SecurityException**：安全相关异常，如权限不足、认证失败等


#### 全局异常处理


## Spring Boot 开发规范

### 1. 控制器规范

- 避免字段注入


### 2. 服务层规范

### 3. 配置类规范

```java
/**
 * Redis 配置
 */
@Configuration
@EnableCaching
@Slf4j
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory, ObjectMapper mapper) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);

        // 设置序列化器
        Jackson2JsonRedisSerializer<Object> serializer =
                new Jackson2JsonRedisSerializer<>(mapper, Object.class);

        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(serializer);
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(serializer);

        template.afterPropertiesSet();
        return template;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(1))
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new Jackson2JsonRedisSerializer<>(Object.class)));

        return RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
    }
}
```

### 4. 事务管理

#### 事务注解使用

```java
/**
 * 用户服务
 */
@Service
@Transactional(rollbackFor = Exception.class)
public class UserService {

    /**
     * 创建用户（只读事务）
     */
    @Transactional(readOnly = true)
    public User getUserById(Long userId) {
        return userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException("用户不存在"));
    }

    /**
     * 创建用户（写事务）
     */
    @Transactional(rollbackFor = Exception.class)
    public User createUser(CreateUserCommand command) {
        // 业务逻辑
        return userRepository.save(user);
    }

    /**
     * 批量操作（新事务）
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void batchProcessUsers(List<User> users) {
        // 批量处理逻辑
    }
}
```

### 5. 缓存使用

#### 缓存注解

```java
/**
 * 用户服务
 */
@Service
@Transactional(rollbackFor = Exception.class)
public class UserService {

    /**
     * 根据ID获取用户（带缓存）
     */
    @Cacheable(value = "users", key = "#userId")
    public User getUserById(Long userId) {
        return userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException("用户不存在"));
    }

    /**
     * 更新用户（清除缓存）
     */
    @CacheEvict(value = "users", key = "#user.id")
    public User updateUser(User user) {
        return userRepository.save(user);
    }

    /**
     * 删除用户（清除缓存）
     */
    @CacheEvict(value = "users", key = "#userId")
    public void deleteUser(Long userId) {
        userRepository.deleteById(userId);
    }
}
```

### 6. 异步处理

```java
/**
 * 异步任务服务
 */
@Service
@Slf4j
public class AsyncTaskService {

    @Async("taskExecutor")
    @Retryable(value = {Exception.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000))
    public CompletableFuture<Void> sendWelcomeEmail(String email) {
        try {
            log.info("发送欢迎邮件到: {}", email);
            // 发送邮件逻辑
            emailService.sendWelcomeEmail(email);
            log.info("欢迎邮件发送成功: {}", email);
            return CompletableFuture.completedFuture(null);
        } catch (Exception e) {
            log.error("发送欢迎邮件失败: {}", email, e);
            throw e;
        }
    }

    @Recover
    public CompletableFuture<Void> recoverSendWelcomeEmail(Exception ex, String email) {
        log.error("发送欢迎邮件最终失败: {}", email, ex);
        // 记录失败日志或发送告警
        return CompletableFuture.completedFuture(null);
    }
}
```

## 测试规范

### 1. 单元测试

```java
/**
 * 用户服务测试类
 */
@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock
    private PasswordEncoder passwordEncoder;

    @InjectMocks
    private UserServiceImpl userService;

    @Test
    @DisplayName("创建用户 - 成功")
    void createUser_Success() {
        // Given
        UserCreateRequest request = UserCreateRequest.builder()
                .username("testuser")
                .email("test@example.com")
                .password("password123")
                .build();

        when(userRepository.existsByEmail(request.getEmail())).thenReturn(false);
        when(passwordEncoder.encode(request.getPassword())).thenReturn("encoded_password");
        when(userRepository.save(any(User.class))).thenAnswer(invocation -> {
            User user = invocation.getArgument(0);
            user.setId(1L);
            return user;
        });

        // When
        User apiResponse = userService.createUser(request);

        // Then
        assertThat(apiResponse).isNotNull();
        assertThat(apiResponse.getId()).isEqualTo(1L);
        assertThat(apiResponse.getUsername()).isEqualTo(request.getUsername());
        assertThat(apiResponse.getEmail()).isEqualTo(request.getEmail());

        verify(userRepository).existsByEmail(request.getEmail());
        verify(passwordEncoder).encode(request.getPassword());
        verify(userRepository).save(any(User.class));
    }

    @Test
    @DisplayName("创建用户 - 邮箱已存在")
    void createUser_EmailExists() {
        // Given
        UserCreateRequest request = UserCreateRequest.builder()
                .email("existing@example.com")
                .build();

        when(userRepository.existsByEmail(request.getEmail())).thenReturn(true);

        // When & Then
        assertThatThrownBy(() -> userService.createUser(request))
                .isInstanceOf(BusinessException.class)
                .hasMessage("邮箱已存在");

        verify(userRepository).existsByEmail(request.getEmail());
        verify(userRepository, never()).save(any(User.class));
    }
}
```

### 2. 集成测试

```java
/**
 * 用户控制器集成测试
 */
@SpringBootTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Testcontainers
class UserControllerIntegrationTest {

    @Container
    static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private UserRepository userRepository;

    @Test
    @DisplayName("创建用户接口测试")
    void createUser_Integration() {
        // Given
        UserCreateRequest request = UserCreateRequest.builder()
                .username("integrationtest")
                .email("integration@test.com")
                .password("password123")
                .build();

        // When
        ResponseEntity<UserResponse> response = restTemplate.postForEntity(
                "/api/v1/users", request, UserResponse.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getUsername()).isEqualTo(request.getUsername());

        // 验证数据库中的数据
        Optional<User> savedUser = userRepository.findByEmail(request.getEmail());
        assertThat(savedUser).isPresent();
        assertThat(savedUser.get().getUsername()).isEqualTo(request.getUsername());
    }
}
```


## 代码质量规范

### 1. 静态代码分析

#### SonarQube配置

```xml
<!-- Maven SonarQube Plugin -->
<plugin>
    <groupId>org.sonarsource.scanner.maven</groupId>
    <artifactId>sonar-maven-plugin</artifactId>
    <version>3.10.0.2594</version>
</plugin>
```

#### SpotBugs配置

```xml
<!-- SpotBugs Maven Plugin -->
<plugin>
    <groupId>com.github.spotbugs</groupId>
    <artifactId>spotbugs-maven-plugin</artifactId>
    <version>4.7.3.6</version>
    <configuration>
        <effort>Max</effort>
        <threshold>Low</threshold>
        <xmlOutput>true</xmlOutput>
    </configuration>
</plugin>
```

### 2. 代码格式化

#### Spotless配置

```xml
<!-- Spotless Maven Plugin -->
<plugin>
    <groupId>com.diffplug.spotless</groupId>
    <artifactId>spotless-maven-plugin</artifactId>
    <version>2.43.0</version>
    <configuration>
        <java>
            <googleJavaFormat>
                <version>1.18.1</version>
                <style>GOOGLE</style>
            </googleJavaFormat>
            <removeUnusedImports/>
            <importOrder>
                <order>java,javax,org,com,</order>
            </importOrder>
        </java>
    </configuration>
</plugin>
```

## 安全规范

### 1. 输入验证

```java
/**
 * 用户创建请求DTO
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserCreateRequest {

    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20个字符之间")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "用户名只能包含字母、数字和下划线")
    private String username;

    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    @Size(max = 100, message = "邮箱长度不能超过100个字符")
    private String email;

    @NotBlank(message = "密码不能为空")
    @Size(min = 8, max = 20, message = "密码长度必须在8-20个字符之间")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d@$!%*?&]+$",
            message = "密码必须包含大小写字母和数字")
    private String password;
}
```

### 2. 权限控制

如果引入了Spring Security，需要在控制器方法上添加权限注解。

```java
/**
 * 用户控制器（带权限控制）
 */
@RestController
@RequestMapping("/api/v1/users")
@PreAuthorize("hasRole('ADMIN')")
public class UserController {

    @PostMapping
    @PreAuthorize("hasAuthority('USER_CREATE')")
    public ApiResponse<UserResponse> createUser(@Valid @RequestBody UserCreateRequest request) {
        // 实现代码
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('USER_READ') or #id == authentication.principal.id")
    public ApiResponse<UserResponse> getUser(@PathVariable Long id) {
        // 实现代码
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('USER_DELETE')")
    public ApiResponse<Void> deleteUser(@PathVariable Long id) {
        // 实现代码
    }
}
```

## 日志规范

### 1. 日志配置

```yaml
# logback-spring.xml 配置
logging:
  level:
    com.company.project: INFO
    org.springframework.security: DEBUG
    com.baomidou.mybatisplus: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%logger{50}] - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%logger{50}] - %msg%n"
  file:
    name: logs/application.log
    max-size: 100MB
    max-history: 30
```

### 2. 日志使用

```java

@Service
@Slf4j
public class UserServiceImpl implements UserService {

    @Override
    public User createUser(UserCreateRequest request) {
        log.info("开始创建用户, email: {}", request.getEmail());

        try {
            // 业务逻辑
            User user = doCreateUser(request);
            log.info("用户创建成功, userId: {}, email: {}", user.getId(), user.getEmail());
            return user;
        } catch (BusinessException e) {
            log.warn("用户创建失败, email: {}, error: {}", request.getEmail(), e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("用户创建异常, email: {}", request.getEmail(), e);
            throw new BusinessException("USER_CREATE_ERROR", "用户创建失败");
        }
    }
}
```

## 配置文件规范

### 1. application.yml

```yaml
server:
  port: 8080

spring:
  application:
    name: project-service

  profiles:
    active: dev

  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/project_db?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD:password}
    hikari:
      minimum-idle: 5
      maximum-pool-size: 20
      idle-timeout: 300000
      connection-timeout: 20000
      max-lifetime: 1200000

  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      database: 0
      lettuce:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 5
        max-wait: 2000ms

  cache:
    type: redis
    redis:
      time-to-live: 3600000
      cache-null-values: false

mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      id-type: auto
      logic-delete-field: deleted
      logic-delete-value: 1
      logic-not-delete-value: 0
  mapper-locations: classpath*:mapper/*.xml

springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html
    tags-sorter: alpha
    operations-sorter: alpha

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: when-authorized
```

## 总结

遵循以上规范，你需要：

1. **严格按照命名规范**编写代码，保持一致性
2. **编写完整的中文注释**，提高代码可读性
3. **实现完善的异常处理**，提供友好的错误信息
4. **使用 Spring Boot 最佳实践**，充分利用框架特性
5. **正确使用 MyBatis Plus**，提高开发效率
6. **合理组织项目结构**，便于维护和扩展
7. **编写全面的测试用例**，保证代码质量
8. **注重安全性**，防范常见安全漏洞
9. **优化性能**，使用缓存和异步处理
10. **规范日志记录**，便于问题排查

请在编写代码时严格遵循这些规范，确保代码质量和项目的可维护性。
