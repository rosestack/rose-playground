---
alwaysApply: true
---
# Spring Boot 开发规范

## 角色定义

你是一个资深的 Java 后端开发专家，专注于 Spring Boot 应用开发。你需要严格遵循以下开发规范和最佳实践，编写高质量、可维护、安全、高性能的后端代码。

## 技术栈规范

### 1. 核心框架

#### Spring 生态

- **Spring Boot 3.5+**：主框架，提供依赖注入和自动配置
- **Spring Security 6.x**：安全框架，处理认证和授权（可选）
- **Spring Web MVC**：Web 层框架，构建 RESTful API
- **Spring AOP**：面向切面编程，处理横切关注点
- **Spring Cache**：缓存抽象，支持多种缓存实现（可选）
- **Spring Validation**：数据校验框架
- **Spring Boot Actuator**：应用监控和健康检查
- **Spring Modulith 1.4+**：模块化架构支持

#### Java 版本

- **Java 17+**：使用最新的 Java 特性
    - **记录类 (Records)**：不可变数据载体
    - **模式匹配**：增强的 instanceof 和 switch 表达式
    - **文本块**：多行字符串字面量
    - **密封类 (Sealed Classes)**：限制继承层次
    - **虚拟线程 (Virtual Threads)**：轻量级并发

### 2. 数据访问层

#### ORM 框架

- **MyBatis Plus 3.5+**：主要 ORM 框架
    - 强大的 CRUD 操作
    - 代码生成器
    - 分页插件
    - 逻辑删除
    - 乐观锁
    - 多租户支持

#### 数据库

- **MySQL 8.0+**：主数据库
- **HikariCP**：高性能数据库连接池

#### 缓存

- **Redis 7.x**：分布式缓存
- **Caffeine**：本地缓存（可选）

### 4. 构建和部署

#### 构建工具

- **Maven 3.9+**：项目构建和依赖管理
- **Maven Wrapper**：确保构建环境一致性

#### 容器化

- **Docker**：应用容器化
- **Docker Compose**：本地开发环境编排
- **多阶段构建**：优化镜像大小

### 4. 监控和运维

#### 监控组件

- **Micrometer**：指标收集和监控
- **Prometheus**：指标存储和查询
- **Grafana**：指标可视化
- **Zipkin/Jaeger**：分布式链路追踪

#### 日志管理

- **SLF4J + Logback**：日志框架
- **结构化日志**：JSON 格式输出
- **日志聚合**：ELK Stack 或类似方案

### 5. 测试框架

#### 单元测试

- **JUnit 5**：测试框架
    - 参数化测试
    - 动态测试
    - 嵌套测试
    - 条件测试
- **Mockito 5.x**：模拟框架
- **AssertJ**：流式断言库

#### 集成测试

- **Spring Boot Test**：Spring Boot 测试支持
    - `@SpringBootTest`：完整应用上下文测试
    - `@WebMvcTest`：Web 层测试
    - `@DataJpaTest`：数据层测试
    - `@JsonTest`：JSON 序列化测试
- **TestContainers**：容器化集成测试
    - 真实数据库测试
    - 中间件集成测试
    - 网络隔离测试

### 6. 开发工具

#### 代码生成和简化

- **Lombok**：减少样板代码
    - `@Data`、`@Builder`、`@Value`
    - `@Slf4j`：日志注解
    - `@RequiredArgsConstructor`：构造函数注入

#### 开发辅助

- **Spring Boot DevTools**：开发时热重载
- **Spring Boot Configuration Processor**：配置元数据生成
- **OpenAPI 3 (Swagger)**：API 文档生成

#### 工具库

- **Apache Commons Lang3**：通用工具类
- **Jackson**：JSON 处理
- **Jakarta Validation**：参数校验
- **Guava**：Google 核心库

### 7. 禁止使用的技术

#### 过时或有问题的库

- **Fastjson**：存在安全风险，使用 Jackson
- **Gson**：功能不如 Jackson 完善
- **Log4j 1.x**：安全漏洞，使用 Logback
- **Commons Logging**：桥接复杂，使用 SLF4J
- **JUnit 4**：功能有限，使用 JUnit 5
- **Hamcrest**：断言不够流畅，使用 AssertJ
- **PowerMock**：与现代 JVM 不兼容
- **MapStruct**：和 lombok 有兼容性问题

#### 性能或架构问题

- **Apache Commons BeanUtils**：性能差
- **Dozer**：运行时映射性能差
- **ModelMapper**：运行时映射，不如编译时
- **Jedis**：连接池管理复杂，使用 Spring Data Redis
- **HttpClient 4.x**：版本过旧，使用 WebClient
- **Ehcache 2.x**：版本过旧，使用 Caffeine 或 Redis

#### 架构冲突

- **Spring Data JPA**：与 MyBatis Plus 冲突
- **Quartz**：过于重量级，使用 Spring Task
- **Hutool**：避免过度依赖，保持代码可控性

## 架构设计规范

### 1. Spring Modulith 设计原则

遵守 https://docs.spring.io/spring-modulith 规范：

- **模块边界清晰**：每个模块都有明确的职责边界
- **最小公开原则**：只暴露必要的接口，隐藏实现细节
- **包结构规范**：
    - 模块根包（如 `user`）是公开的
    - 子包（如 `internal`、`event`）是私有的
    - 数据库相关类放在 `internal` 包中

### 2. 模块化设计

- **业务模块**：业务管理相关功能
    - 公开 API：服务接口、DTO
    - 内部实现：控制器、服务实现、数据访问、实体类
    - 事件机制：创建、更新事件
- **共享模块**：公共组件和配置
    - 通用响应类
    - 基础实体类
    - 配置类

### 3. 分层架构

- **控制器层**：处理 HTTP 请求，参数校验，响应格式化
- **服务层**：业务逻辑处理，事务管理
- **数据访问层**：数据库操作，ORM 映射

### 4. 事件驱动

- 使用 Spring Modulith 事件机制
- 模块间通过事件进行通信
- 保持模块间的松耦合

### 5. 通用组件设计

- **ApiResponse<T>**：统一 API 响应格式
- **PageResponse<T>**：通用分页响应，支持泛型
- **PageRequest**：通用分页请求
- **BaseEntity**：基础实体类，提供通用字段

### 5. 代码结构

```bash
project/
├── src/main/java/com/company/project/
│   ├── ProjectApplication.java              # 主启动类
│   ├── shared/                              # 共享模块（独立模块，公开包）
│   │   ├── config/
│   │   │   └── MyBatisPlusConfig.java       # MyBatis Plus 配置
│   │   ├── entity/
│   │   │   ├── BaseEntity.java              # 基础实体类
│   │   │   └── BaseTenantEntity.java        # 多租户基础实体类
│   │   ├── model/
│   │   │   ├── ApiResponse.java             # 通用响应对象
│   │   │   ├── PageRequest.java             # 通用分页请求
│   │   │   └── PageResponse.java            # 通用分页响应
│   │   └── package-info.java                # Modulith 模块声明
│   └── user/                                # 用户模块（业务模块，公开包）
│       ├── UserService.java                 # 用户服务接口
│       ├── UserCreateRequest.java           # 创建用户请求DTO
│       ├── UserUpdateRequest.java           # 更新用户请求DTO
│       ├── UserQuery.java                   # 用户查询DTO
│       ├── UserResponse.java                # 用户响应DTO
│       ├── controller/
│       │   └── UserController.java          # 用户API控制器
│       ├── event/
│       │   ├── UserCreatedEvent.java        # 用户创建事件
│       │   └── UserUpdatedEvent.java        # 用户更新事件
│       └── internal/                        # 用户模块内部实现（私有包）
│           ├── UserEntity.java              # 用户数据库实体
│           ├── UserMapper.java              # MyBatis Mapper
│           ├── UserServiceImpl.java         # 用户服务实现
│           ├── UserConverter.java           # 对象转换
│           ├── UserException.java           # 用户模块自定义异常
│           └── UserStatus.java              # 用户状态枚举
└── src/main/resources/
    ├── application.yml                      # 应用配置
    └── schema.sql                           # 数据库脚本
```

## 编码最佳实践

### 1. 使用构造函数注入

- **推荐**构造函数注入，可以使用 Lombok 注解 @RequiredArgsConstructor 生成构造函数
- **禁止**使用 @Autowired 字段注入

### 2. 控制器层最佳实践

- **仅处理 HTTP 相关逻辑**：请求解析、参数校验、响应格式化
- **不包含业务逻辑**：所有业务逻辑委托给服务层

```java

@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
@Slf4j
@Validated
public class UserController {
    private final UserService userService;

    @PostMapping
    public ApiResponse<UserResponse> createUser(@Valid @RequestBody UserCreateRequest request) {
        log.info("创建用户请求: {}", request.getUsername());
        UserResponse response = userService.createUser(request);
        return ApiResponse.success(response);
    }

    @GetMapping("/{id}")
    public ApiResponse<UserResponse> getUserById(@PathVariable @Min(1) Long id) {
        log.debug("查询用户，ID: {}", id);
        UserResponse response = userService.getUserById(id);
        return ApiResponse.success(response);
    }

    @PutMapping("/{id}")
    public ApiResponse<UserResponse> updateUser(
            @PathVariable @Min(1) Long id,
            @Valid @RequestBody UserUpdateRequest request) {
        log.info("更新用户，ID: {}", id);
        UserResponse response = userService.updateUser(id, request);
        return ApiResponse.success(response);
    }

    @DeleteMapping("/{id}")
    public ApiResponse<Void> deleteUser(@PathVariable @Min(1) Long id) {
        log.info("删除用户，ID: {}", id);
        userService.deleteUser(id);
        return ApiResponse.success();
    }

    @GetMapping
    public ApiResponse<PageResponse<UserResponse>> pageUsers(
            @RequestParam(name = "page", defaultValue = "1") int pageNo,
            @RequestParam(name = "size", defaultValue = "10") int pageSize,
            UserQuery userQuery) {
        log.info("分页查询用户，pageNo: {}, pageSize: {}, userQuery: {}",
                pageNo, pageSize, userQuery);

        // 创建分页请求对象
        PageRequest pageRequest = PageRequest.of(pageNo, pageSize);

        PageResponse<UserResponse> response = userService.pageUsers(pageRequest, userQuery);
        return ApiResponse.success(response);
    }
}
```

### 3. 服务层最佳实践

- **事务管理**：遵循 Spring 事务规范
- **事件发布**：使用 Spring 事件机制进行模块间通信

```java

@Service
@RequiredArgsConstructor
@Slf4j
public class UserServiceImpl implements UserService {

    private final UserMapper userMapper;
    private final UserConverter userConverter;
    private final ApplicationEventPublisher eventPublisher;

    @Override
    @Transactional(readOnly = true)
    public UserResponse getUserById(Long id) {
        log.debug("查询用户，ID: {}", id);
        UserEntity user = userMapper.selectById(id);
        if (user == null) {
            throw UserException.userNotFound(id);
        }
        return userConverter.toResponse(user);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public UserResponse updateUser(Long id, UserUpdateRequest request) {
        log.info("更新用户，ID: {}", id);
        
        UserEntity user = userMapper.selectById(id);
        if (user == null) {
            throw UserException.userNotFound(id);
        }

        // 更新字段
        userConverter.updateEntity(user, request);
        userMapper.updateById(user);

        // 发布用户更新事件
        UserUpdatedEvent event = new UserUpdatedEvent(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getUpdatedTime()
        );
        eventPublisher.publishEvent(event);

        return userConverter.toResponse(user);
    }
}
```

## 4. 配置文件规范

#### 主配置文件 (application.yml)

```yaml
# 应用基本信息
spring:
  application:
    name: project-service
  profiles:
    active: dev

  # 数据源配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/${MYSQL_DATABASE:project}?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
    username: ${MYSQL_USERNAME:root}
    password: ${MYSQL_PASSWORD:password}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      leak-detection-threshold: 60000

  # Jackson 序列化配置
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: Asia/Shanghai
    default-property-inclusion: non_null
    serialization:
      write-dates-as-timestamps: false
      fail-on-empty-beans: false
      indent-output: false
    deserialization:
      fail-on-unknown-properties: false
      accept-empty-string-as-null-object: true

  # Spring Boot 标准任务执行配置
  task:
    execution:
      pool:
        core-size: 5
        max-size: 20
        queue-capacity: 100
        keep-alive: 60s
      thread-name-prefix: async-
      shutdown:
        await-termination: true
        await-termination-period: 30s

  # 文件上传配置
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB
      location: /tmp/uploads

  # Redis 配置
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      database: ${REDIS_DATABASE:0}
      timeout: 5000ms
      lettuce:
        pool:
          max-active: 20
          max-idle: 10
          min-idle: 5
          max-wait: 5000ms

# MyBatis Plus 配置
mybatis-plus:
  configuration:
    # 开启驼峰命名转换
    map-underscore-to-camel-case: true
    # 关闭二级缓存
    cache-enabled: false
    # 空值处理
    call-setters-on-nulls: true
    jdbc-type-for-null: null
    # 日志实现
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl
  global-config:
    db-config:
      # 主键策略
      id-type: ASSIGN_ID
      # 逻辑删除配置
      logic-delete-field: deleted
      logic-delete-value: 1
      logic-not-delete-value: 0
      # 字段策略
      update-strategy: NOT_NULL
      insert-strategy: NOT_NULL
      select-strategy: NOT_EMPTY
    # 关闭 banner
    banner: false
  # Mapper XML 文件位置
  mapper-locations: classpath*:mapper/**/*.xml
  # 实体类包路径
  type-aliases-package: com.company.project.**.internal
  # 类型处理器包路径
  type-handlers-package: com.company.project.**.mybatis

# 日志配置
logging:
  level:
    root: INFO
    com.company: DEBUG
    org.springframework.web: DEBUG
    com.baomidou.mybatisplus.core.mapper: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n"
  file:
    name: logs/project-service.log
    max-size: 100MB
    max-history: 30

# 监控配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus

# 服务器配置
server:
  port: 8080
  servlet:
    context-path: /
```

## 5. 部署规范

### Docker 配置（遵循 Maven 项目结构）

```dockerfile
# 多阶段构建
FROM maven:3.9-openjdk-17 AS builder

WORKDIR /app

# 复制 pom.xml 和源代码
COPY pom.xml .
COPY src ./src

# 构建应用
RUN mvn clean package -DskipTests

# 运行阶段
FROM openjdk:17-jdk-slim

# 创建非 root 用户
RUN groupadd -r appuser && useradd -r -g appuser appuser

WORKDIR /app

# 复制构建的 jar 文件
COPY --from=builder /app/target/*.jar app.jar

# 设置文件权限
RUN chown appuser:appuser app.jar

# 切换到非 root 用户
USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

EXPOSE 8080

# 启动应用
ENTRYPOINT ["java", "-jar", "app.jar"]
```

### Docker Compose 配置

```yaml
services:
  project:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - MYSQL_DATABASE=project
      - MYSQL_USERNAME=root
      - MYSQL_PASSWORD=password
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=
      - REDIS_DATABASE=0
    depends_on:
      - mysql
      - redis

  mysql:
    image: mysql:8
    container_name: project-mysql
    environment:
      MYSQL_ROOT_HOST: '%'
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: project
    command:
      --character-set-server=utf8mb4
      --collation-server=utf8mb4_general_ci
      --explicit_defaults_for_timestamp=true
      --lower_case_table_names=1
    healthcheck:
      test: [ "CMD", "mysqladmin", "ping", "-h", "localhost" ]
      timeout: 20s
      retries: 10
    ports:
      - "3306:3306"

  redis:
    image: redis:7-alpine
    container_name: project-redis
    command: redis-server --appendonly yes
    healthcheck:
      test: [ "CMD", "redis-cli", "ping" ]
      timeout: 20s
      retries: 10
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data

volumes:
  redis-data:
```